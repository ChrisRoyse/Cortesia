//! Report Writers for Different Output Formats
//! 
//! Implements various report output formats (HTML, JSON, JUnit XML).

use anyhow::Result;
use async_trait::async_trait;
use serde_json;
use std::path::PathBuf;
use tokio::fs;
use crate::infrastructure::TestReport;

/// Trait for report writers
#[async_trait]
pub trait ReportWriter: Send + Sync {
    async fn write_report(&self, report: &TestReport) -> Result<()>;
}

/// HTML report writer
pub struct HtmlReportWriter {
    output_path: PathBuf,
}

impl HtmlReportWriter {
    pub fn new(output_path: PathBuf) -> Result<Self> {
        Ok(Self { output_path })
    }
    
    fn generate_html(&self, report: &TestReport) -> String {
        let pass_rate = if report.total_tests > 0 {
            (report.passed_tests as f64 / report.total_tests as f64) * 100.0
        } else {
            0.0
        };

        let status_color = if pass_rate >= 90.0 {
            "green"
        } else if pass_rate >= 70.0 {
            "orange"
        } else {
            "red"
        };

        format!(r#"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLMKG Test Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .header {{ text-align: center; margin-bottom: 30px; }}
        .status {{ font-size: 24px; font-weight: bold; color: {}; }}
        .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }}
        .summary-card {{ background-color: #f8f9fa; padding: 15px; border-radius: 5px; text-align: center; }}
        .summary-card h3 {{ margin: 0; color: #333; }}
        .summary-card .number {{ font-size: 2em; font-weight: bold; color: #007bff; }}
        .test-results {{ margin-top: 30px; }}
        .test-item {{ border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; }}
        .test-header {{ padding: 10px; background-color: #f8f9fa; cursor: pointer; }}
        .test-header.passed {{ border-left: 4px solid #28a745; }}
        .test-header.failed {{ border-left: 4px solid #dc3545; }}
        .test-details {{ padding: 15px; display: none; }}
        .error {{ background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 10px; border-radius: 4px; margin-top: 10px; }}
        .performance {{ background-color: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460; padding: 10px; border-radius: 4px; margin-top: 10px; }}
        .footer {{ text-align: center; margin-top: 30px; color: #666; font-size: 0.9em; }}
    </style>
    <script>
        function toggleDetails(element) {{
            const details = element.nextElementSibling;
            details.style.display = details.style.display === 'none' ? 'block' : 'none';
        }}
    </script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>LLMKG Unit Test Report</h1>
            <div class="status">{:.1}% Pass Rate</div>
            <p>Generated on {}</p>
        </div>
        
        <div class="summary">
            <div class="summary-card">
                <h3>Total Tests</h3>
                <div class="number">{}</div>
            </div>
            <div class="summary-card">
                <h3>Passed</h3>
                <div class="number" style="color: #28a745;">{}</div>
            </div>
            <div class="summary-card">
                <h3>Failed</h3>
                <div class="number" style="color: #dc3545;">{}</div>
            </div>
            <div class="summary-card">
                <h3>Coverage</h3>
                <div class="number" style="color: #17a2b8;">{:.1}%</div>
            </div>
            <div class="summary-card">
                <h3>Duration</h3>
                <div class="number" style="color: #6f42c1;">{:.2}s</div>
            </div>
        </div>

        <div class="test-results">
            <h2>Test Results</h2>
            {}
        </div>

        <div class="footer">
            <p>Generated by LLMKG Test Framework v{}</p>
        </div>
    </div>
</body>
</html>
        "#, 
            status_color,
            pass_rate,
            report.timestamp.format("%Y-%m-%d %H:%M:%S UTC"),
            report.total_tests,
            report.passed_tests,
            report.failed_tests,
            report.coverage_percentage,
            report.total_duration.as_secs_f64(),
            self.generate_test_items(report),
            report.environment_info.test_runner_version
        )
    }

    fn generate_test_items(&self, report: &TestReport) -> String {
        report.test_summaries.iter()
            .map(|test| {
                let status_class = if test.status == "PASSED" { "passed" } else { "failed" };
                let status_icon = if test.status == "PASSED" { "✓" } else { "✗" };
                
                let error_section = if let Some(ref error) = test.error_message {
                    format!(r#"<div class="error"><strong>Error:</strong> {}</div>"#, error)
                } else {
                    String::new()
                };

                let performance_section = if let Some(ref perf) = test.performance_metrics {
                    format!(r#"<div class="performance">
                        <strong>Performance:</strong><br>
                        CPU: {:.1}% | Memory: {:.2}MB | Duration: {:.2}ms
                    </div>"#, 
                        perf.cpu_usage_percent,
                        test.memory_usage as f64 / (1024.0 * 1024.0),
                        test.duration.as_millis()
                    )
                } else {
                    format!(r#"<div class="performance">
                        <strong>Performance:</strong><br>
                        Memory: {:.2}MB | Duration: {:.2}ms
                    </div>"#,
                        test.memory_usage as f64 / (1024.0 * 1024.0),
                        test.duration.as_millis()
                    )
                };

                format!(r#"
                <div class="test-item">
                    <div class="test-header {}" onclick="toggleDetails(this)">
                        <strong>{} {}</strong> - {:.2}ms
                    </div>
                    <div class="test-details">
                        {}
                        {}
                    </div>
                </div>
                "#, status_class, status_icon, test.name, test.duration.as_millis(), error_section, performance_section)
            })
            .collect::<Vec<_>>()
            .join("")
    }
}

#[async_trait]
impl ReportWriter for HtmlReportWriter {
    async fn write_report(&self, report: &TestReport) -> Result<()> {
        let html_content = self.generate_html(report);
        
        // Ensure parent directory exists
        if let Some(parent) = self.output_path.parent() {
            fs::create_dir_all(parent).await?;
        }
        
        fs::write(&self.output_path, html_content).await?;
        Ok(())
    }
}

/// JSON report writer
pub struct JsonReportWriter {
    output_path: PathBuf,
}

impl JsonReportWriter {
    pub fn new(output_path: PathBuf) -> Result<Self> {
        Ok(Self { output_path })
    }
}

#[async_trait]
impl ReportWriter for JsonReportWriter {
    async fn write_report(&self, report: &TestReport) -> Result<()> {
        let json_content = serde_json::to_string_pretty(report)?;
        
        // Ensure parent directory exists
        if let Some(parent) = self.output_path.parent() {
            fs::create_dir_all(parent).await?;
        }
        
        fs::write(&self.output_path, json_content).await?;
        Ok(())
    }
}

/// JUnit XML report writer
pub struct JunitXmlWriter {
    output_path: PathBuf,
}

impl JunitXmlWriter {
    pub fn new(output_path: PathBuf) -> Result<Self> {
        Ok(Self { output_path })
    }

    fn generate_junit_xml(&self, report: &TestReport) -> String {
        let test_cases = report.test_summaries.iter()
            .map(|test| {
                let failure_section = if test.status == "FAILED" {
                    if let Some(ref error) = test.error_message {
                        format!(r#"<failure message="Test failed">{}</failure>"#, 
                            self.escape_xml(error))
                    } else {
                        "<failure message=\"Test failed\">Unknown error</failure>".to_string()
                    }
                } else {
                    String::new()
                };

                format!(r#"
    <testcase name="{}" classname="llmkg.unit_tests" time="{:.3}">
        {}
    </testcase>"#,
                    self.escape_xml(&test.name),
                    test.duration.as_secs_f64(),
                    failure_section
                )
            })
            .collect::<Vec<_>>()
            .join("");

        format!(r#"<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
    <testsuite name="LLMKG Unit Tests" 
               tests="{}" 
               failures="{}" 
               errors="0" 
               time="{:.3}" 
               timestamp="{}">
        {}
    </testsuite>
</testsuites>"#,
            report.total_tests,
            report.failed_tests,
            report.total_duration.as_secs_f64(),
            report.timestamp.format("%Y-%m-%dT%H:%M:%S"),
            test_cases
        )
    }

    fn escape_xml(&self, text: &str) -> String {
        text.replace('&', "&amp;")
            .replace('<', "&lt;")
            .replace('>', "&gt;")
            .replace('"', "&quot;")
            .replace('\'', "&apos;")
    }
}

#[async_trait]
impl ReportWriter for JunitXmlWriter {
    async fn write_report(&self, report: &TestReport) -> Result<()> {
        let xml_content = self.generate_junit_xml(report);
        
        // Ensure parent directory exists
        if let Some(parent) = self.output_path.parent() {
            fs::create_dir_all(parent).await?;
        }
        
        fs::write(&self.output_path, xml_content).await?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;
    use crate::infrastructure::{TestSummary, PerformanceSummary, EnvironmentInfo};

    fn create_test_report() -> TestReport {
        TestReport {
            timestamp: chrono::Utc::now(),
            total_tests: 2,
            passed_tests: 1,
            failed_tests: 1,
            skipped_tests: 0,
            total_duration: Duration::from_millis(300),
            coverage_percentage: 85.0,
            test_summaries: vec![
                TestSummary {
                    name: "test_pass".to_string(),
                    status: "PASSED".to_string(),
                    duration: Duration::from_millis(100),
                    memory_usage: 1024,
                    error_message: None,
                    performance_metrics: None,
                },
                TestSummary {
                    name: "test_fail".to_string(),
                    status: "FAILED".to_string(),
                    duration: Duration::from_millis(200),
                    memory_usage: 2048,
                    error_message: Some("Assertion failed".to_string()),
                    performance_metrics: None,
                },
            ],
            performance_summary: PerformanceSummary {
                average_test_duration: Duration::from_millis(150),
                slowest_test: Some("test_fail".to_string()),
                fastest_test: Some("test_pass".to_string()),
                total_memory_usage: 3072,
                peak_memory_usage: 2048,
                cpu_usage_percentage: 25.0,
            },
            environment_info: EnvironmentInfo {
                platform: "windows".to_string(),
                rust_version: "1.70.0".to_string(),
                cpu_count: 8,
                total_memory: 16_000_000_000,
                test_runner_version: "0.1.0".to_string(),
            },
        }
    }

    #[tokio::test]
    async fn test_html_report_generation() {
        let temp_dir = tempfile::tempdir().unwrap();
        let output_path = temp_dir.path().join("test_report.html");
        
        let writer = HtmlReportWriter::new(output_path.clone()).unwrap();
        let report = create_test_report();
        
        writer.write_report(&report).await.unwrap();
        
        assert!(output_path.exists());
        let content = fs::read_to_string(&output_path).await.unwrap();
        assert!(content.contains("LLMKG Unit Test Report"));
        assert!(content.contains("test_pass"));
        assert!(content.contains("test_fail"));
    }

    #[tokio::test]
    async fn test_json_report_generation() {
        let temp_dir = tempfile::tempdir().unwrap();
        let output_path = temp_dir.path().join("test_report.json");
        
        let writer = JsonReportWriter::new(output_path.clone()).unwrap();
        let report = create_test_report();
        
        writer.write_report(&report).await.unwrap();
        
        assert!(output_path.exists());
        let content = fs::read_to_string(&output_path).await.unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&content).unwrap();
        assert_eq!(parsed["total_tests"], 2);
        assert_eq!(parsed["passed_tests"], 1);
    }

    #[tokio::test]
    async fn test_junit_xml_generation() {
        let temp_dir = tempfile::tempdir().unwrap();
        let output_path = temp_dir.path().join("junit.xml");
        
        let writer = JunitXmlWriter::new(output_path.clone()).unwrap();
        let report = create_test_report();
        
        writer.write_report(&report).await.unwrap();
        
        assert!(output_path.exists());
        let content = fs::read_to_string(&output_path).await.unwrap();
        assert!(content.contains("<?xml version=\"1.0\""));
        assert!(content.contains("testcase name=\"test_pass\""));
        assert!(content.contains("testcase name=\"test_fail\""));
        assert!(content.contains("<failure"));
    }
}