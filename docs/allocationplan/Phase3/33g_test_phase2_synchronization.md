# Task 33g: Test Phase2 Synchronization

**Estimated Time**: 5 minutes  
**Dependencies**: 33f  
**Stage**: Data Integrity Testing  

## Objective
Validate Phase 2 memory pool state matches Phase 3 graph state.

## Implementation Steps

1. Create `tests/integrity/phase2_sync_test.rs`:
```rust
mod common;
use common::*;
use llmkg::phase2_integration::Phase2SyncValidator;

#[tokio::test]
async fn test_memory_pool_graph_synchronization() {
    let brain_graph = setup_integrity_test_graph().await;
    
    // Allocate memory through Phase 3 (should sync to Phase 2)
    let concept_id = "sync_test_concept";
    let req = create_test_concept_request(concept_id);
    
    let allocation_result = brain_graph
        .allocate_memory_with_cortical_coordination(req)
        .await
        .expect("Failed to allocate memory");
    
    // Validate synchronization
    let sync_report = brain_graph
        .validate_phase2_synchronization()
        .await
        .expect("Failed to validate Phase 2 sync");
    
    assert!(sync_report.is_synchronized, "Phase 2 should be synchronized");
    assert_eq!(sync_report.desynchronized_concepts.len(), 0);
    assert_eq!(sync_report.orphaned_allocations.len(), 0);
    
    // Verify memory slot exists in Phase 2
    let memory_slot_id = allocation_result.memory_slot.id;
    
    let phase2_slot = brain_graph
        .get_phase2_memory_slot(&memory_slot_id)
        .await
        .expect("Memory slot should exist in Phase 2");
    
    assert_eq!(phase2_slot.concept_id, Some(concept_id.to_string()));
    assert!(phase2_slot.is_allocated);
}

#[tokio::test]
async fn test_ttfs_encoding_synchronization() {
    let brain_graph = setup_integrity_test_graph().await;
    
    let concept_id = "ttfs_sync_test";
    let content = "Content for TTFS encoding synchronization test";
    
    // Create concept with TTFS encoding
    let req = MemoryAllocationRequest {
        concept_id: concept_id.to_string(),
        concept_type: ConceptType::Semantic,
        content: content.to_string(),
        semantic_embedding: None, // Will be generated by TTFS
        priority: AllocationPriority::Normal,
        resource_requirements: ResourceRequirements::default(),
        locality_hints: vec![],
        user_id: "sync_test_user".to_string(),
        request_id: "ttfs_sync_req".to_string(),
        version_info: None,
    };
    
    brain_graph.allocate_memory_with_cortical_coordination(req).await.unwrap();
    
    // Validate TTFS synchronization
    let ttfs_sync_report = brain_graph
        .validate_ttfs_synchronization()
        .await
        .unwrap();
    
    assert!(ttfs_sync_report.is_synchronized, "TTFS should be synchronized");
    assert_eq!(ttfs_sync_report.encoding_mismatches.len(), 0);
    
    // Verify encoding consistency between phases
    let phase3_concept = brain_graph.get_concept(concept_id).await.unwrap();
    let phase2_encoding = brain_graph
        .get_phase2_ttfs_encoding(concept_id)
        .await
        .unwrap();
    
    assert!(phase3_concept.semantic_embedding.is_some());
    assert_eq!(phase3_concept.semantic_embedding.unwrap(), phase2_encoding.spike_pattern);
}

#[tokio::test]
async fn test_cortical_column_mapping_sync() {
    let brain_graph = setup_integrity_test_graph().await;
    
    let concept_id = "cortical_sync_test";
    let req = create_test_concept_request(concept_id);
    
    let allocation_result = brain_graph
        .allocate_memory_with_cortical_coordination(req)
        .await
        .unwrap();
    
    // Validate cortical column synchronization
    let cortical_sync_report = brain_graph
        .validate_cortical_synchronization()
        .await
        .unwrap();
    
    assert!(cortical_sync_report.is_synchronized, "Cortical mapping should be synchronized");
    assert_eq!(cortical_sync_report.unmapped_concepts.len(), 0);
    assert_eq!(cortical_sync_report.orphaned_mappings.len(), 0);
    
    // Verify cortical column assignment
    let cortical_assignment = allocation_result.cortical_assignment.unwrap();
    
    let phase2_column = brain_graph
        .get_phase2_cortical_column(&cortical_assignment.column_id)
        .await
        .unwrap();
    
    assert!(phase2_column.allocated_concepts.contains(&concept_id.to_string()));
    assert_eq!(phase2_column.total_allocated, phase2_column.allocated_concepts.len());
}

#[tokio::test]
async fn test_desynchronization_detection() {
    let brain_graph = setup_integrity_test_graph().await;
    
    // Create concept normally
    let concept_id = "desync_test_concept";
    let req = create_test_concept_request(concept_id);
    brain_graph.allocate_memory_with_cortical_coordination(req).await.unwrap();
    
    // Simulate desynchronization by modifying Phase 2 directly
    brain_graph.modify_phase2_memory_pool_directly(
        concept_id,
        "Directly modified content"
    ).await.unwrap();
    
    // Validate synchronization - should detect desynchronization
    let sync_report = brain_graph
        .validate_phase2_synchronization()
        .await
        .unwrap();
    
    assert!(!sync_report.is_synchronized, "Should detect desynchronization");
    assert!(sync_report.desynchronized_concepts.len() > 0);
    
    let desync_concept = &sync_report.desynchronized_concepts[0];
    assert_eq!(desync_concept.concept_id, concept_id);
    assert!(desync_concept.phase2_content != desync_concept.phase3_content);
    
    // Test resynchronization
    brain_graph.resynchronize_with_phase2().await.unwrap();
    
    let post_resync_report = brain_graph
        .validate_phase2_synchronization()
        .await
        .unwrap();
    
    assert!(post_resync_report.is_synchronized, "Should be synchronized after resync");
}
```

## Acceptance Criteria
- [ ] Phase 2 synchronization test created
- [ ] Test validates memory pool sync
- [ ] Test validates TTFS encoding sync
- [ ] Test validates cortical column sync

## Success Metrics
- Phase 2 and Phase 3 states match
- Desynchronization is detected
- Resynchronization works correctly

## Next Task
33h_test_error_recovery.md