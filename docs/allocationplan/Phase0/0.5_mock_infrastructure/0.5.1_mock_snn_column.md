# Micro-Phase 0.5.1: Create Mock SNN Column

## Objective
Create mock implementations of the spiking neural network column for testing purposes.

## Prerequisites
- snn-mocks crate created (0.1.3 complete)
- Understanding of the real SpikingCorticalColumn interface

## Input
- SpikingCorticalColumn interface from neuromorphic-core
- Testing requirements
- Deterministic behavior needs

## Task Details

### Step 1: Create Mock Column Structure
Implement a simplified version of SpikingCorticalColumn for testing.

### Step 2: Add Configurable Behavior
Allow tests to configure mock responses and behavior.

### Step 3: Implement Deterministic Responses
Ensure mock behavior is predictable and repeatable.

### Step 4: Add Test Helpers
Create utilities for common test scenarios.

## Expected Output
- `src/mock_snn_column.rs` implemented
- Configurable mock behavior
- Deterministic test responses
- Helper functions for test setup

## Verification Steps
1. Run `cargo test` in snn-mocks crate
2. Verify mock implements same interface
3. Check deterministic behavior
4. Confirm test helpers work

## Time Estimate
30-40 minutes

## AI Execution Prompt
```
Create mock implementations for testing SNN components.

1. Update snn-mocks src/lib.rs:
```rust
//! Mock implementations for testing
//! 
//! Provides test doubles for SNN components.

pub mod mock_snn_column;
pub mod mock_ttfs_allocator;
pub mod mock_inhibition;
pub mod mock_simd;

pub use mock_snn_column::{MockSpikingColumn, MockColumnBuilder};
pub use mock_ttfs_allocator::MockTTFSAllocator;
pub use mock_inhibition::MockLateralInhibition;
pub use mock_simd::MockSIMDProcessor;

/// Prelude for convenient imports
pub mod prelude {
    pub use super::mock_snn_column::*;
    pub use super::MockTTFSAllocator;
    pub use super::MockLateralInhibition;
}
```

2. Create src/mock_snn_column.rs:

```rust
//! Mock implementation of spiking cortical column

use neuromorphic_core::spiking_column::{
    ColumnState, ColumnId, SpikeTiming, InhibitoryWeight, ColumnError
};
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use std::collections::HashMap;

/// Configuration for mock behavior
#[derive(Debug, Clone)]
pub struct MockConfig {
    /// Fixed activation level to return
    pub fixed_activation: Option<f32>,
    
    /// Whether allocation should succeed
    pub allow_allocation: bool,
    
    /// Delay before allocation succeeds
    pub allocation_delay: Option<Duration>,
    
    /// Whether to track method calls
    pub track_calls: bool,
    
    /// Custom error to return
    pub error_on_allocate: Option<ColumnError>,
    
    /// Spike pattern to return
    pub spike_on_threshold: bool,
}

impl Default for MockConfig {
    fn default() -> Self {
        Self {
            fixed_activation: None,
            allow_allocation: true,
            allocation_delay: None,
            track_calls: false,
            error_on_allocate: None,
            spike_on_threshold: true,
        }
    }
}

/// Mock implementation of SpikingCorticalColumn
#[derive(Clone)]
pub struct MockSpikingColumn {
    id: ColumnId,
    state: Arc<Mutex<ColumnState>>,
    activation: Arc<Mutex<f32>>,
    allocated_concept: Arc<Mutex<Option<String>>>,
    config: MockConfig,
    call_history: Arc<Mutex<Vec<String>>>,
    lateral_connections: Arc<Mutex<HashMap<ColumnId, InhibitoryWeight>>>,
    spike_count: Arc<Mutex<u64>>,
}

impl MockSpikingColumn {
    /// Create new mock column
    pub fn new(id: ColumnId) -> Self {
        Self {
            id,
            state: Arc::new(Mutex::new(ColumnState::Available)),
            activation: Arc::new(Mutex::new(0.0)),
            allocated_concept: Arc::new(Mutex::new(None)),
            config: MockConfig::default(),
            call_history: Arc::new(Mutex::new(Vec::new())),
            lateral_connections: Arc::new(Mutex::new(HashMap::new())),
            spike_count: Arc::new(Mutex::new(0)),
        }
    }
    
    /// Create with custom config
    pub fn with_config(id: ColumnId, config: MockConfig) -> Self {
        let mut mock = Self::new(id);
        mock.config = config;
        mock
    }
    
    /// Record a method call
    fn record_call(&self, method: &str) {
        if self.config.track_calls {
            self.call_history.lock().unwrap().push(method.to_string());
        }
    }
    
    /// Get call history
    pub fn call_history(&self) -> Vec<String> {
        self.call_history.lock().unwrap().clone()
    }
    
    /// Reset mock state
    pub fn reset(&self) {
        *self.state.lock().unwrap() = ColumnState::Available;
        *self.activation.lock().unwrap() = 0.0;
        *self.allocated_concept.lock().unwrap() = None;
        self.call_history.lock().unwrap().clear();
        self.lateral_connections.lock().unwrap().clear();
        *self.spike_count.lock().unwrap() = 0;
    }
    
    // SpikingCorticalColumn interface implementation
    
    pub fn id(&self) -> ColumnId {
        self.id
    }
    
    pub fn state(&self) -> ColumnState {
        self.record_call("state");
        *self.state.lock().unwrap()
    }
    
    pub fn activation_level(&self) -> f32 {
        self.record_call("activation_level");
        
        if let Some(fixed) = self.config.fixed_activation {
            fixed
        } else {
            *self.activation.lock().unwrap()
        }
    }
    
    pub fn activate(&self, strength: f32) -> Result<(), ColumnError> {
        self.record_call("activate");
        
        let mut state = self.state.lock().unwrap();
        if *state == ColumnState::Available || *state == ColumnState::Activated {
            *state = ColumnState::Activated;
            *self.activation.lock().unwrap() = strength;
            Ok(())
        } else {
            Err(ColumnError::InvalidTransition(*state, ColumnState::Activated))
        }
    }
    
    pub fn try_allocate(&self, concept_name: String) -> Result<(), ColumnError> {
        self.record_call("try_allocate");
        
        // Check for configured error
        if let Some(ref error) = self.config.error_on_allocate {
            return Err(error.clone());
        }
        
        // Apply delay if configured
        if let Some(delay) = self.config.allocation_delay {
            std::thread::sleep(delay);
        }
        
        if !self.config.allow_allocation {
            return Err(ColumnError::AlreadyAllocated);
        }
        
        let mut state = self.state.lock().unwrap();
        
        if *state == ColumnState::Allocated {
            return Err(ColumnError::AlreadyAllocated);
        }
        
        // Simulate state transitions
        if *state == ColumnState::Available {
            *state = ColumnState::Activated;
        }
        if *state == ColumnState::Activated {
            *state = ColumnState::Competing;
        }
        
        *state = ColumnState::Allocated;
        *self.allocated_concept.lock().unwrap() = Some(concept_name);
        
        Ok(())
    }
    
    pub fn add_lateral_connection(&self, target: ColumnId, weight: InhibitoryWeight) {
        self.record_call("add_lateral_connection");
        self.lateral_connections.lock().unwrap().insert(target, weight);
    }
    
    pub fn connection_strength_to(&self, target: ColumnId) -> Option<InhibitoryWeight> {
        self.record_call("connection_strength_to");
        self.lateral_connections.lock().unwrap().get(&target).cloned()
    }
    
    pub fn should_spike(&self) -> bool {
        self.record_call("should_spike");
        
        if self.config.spike_on_threshold {
            self.activation_level() > 0.7
        } else {
            false
        }
    }
    
    pub fn process_spike(&self) -> Option<SpikeTiming> {
        self.record_call("process_spike");
        
        if self.should_spike() {
            *self.spike_count.lock().unwrap() += 1;
            Some(Duration::from_millis(10)) // Fixed timing for tests
        } else {
            None
        }
    }
    
    pub fn allocated_concept(&self) -> Option<String> {
        self.record_call("allocated_concept");
        self.allocated_concept.lock().unwrap().clone()
    }
    
    pub fn spike_count(&self) -> u64 {
        *self.spike_count.lock().unwrap()
    }
}

/// Builder for creating configured mock columns
pub struct MockColumnBuilder {
    id: ColumnId,
    config: MockConfig,
    initial_state: ColumnState,
    initial_activation: f32,
}

impl MockColumnBuilder {
    /// Create new builder
    pub fn new(id: ColumnId) -> Self {
        Self {
            id,
            config: MockConfig::default(),
            initial_state: ColumnState::Available,
            initial_activation: 0.0,
        }
    }
    
    /// Set fixed activation level
    pub fn with_fixed_activation(mut self, level: f32) -> Self {
        self.config.fixed_activation = Some(level);
        self
    }
    
    /// Set whether allocation is allowed
    pub fn allow_allocation(mut self, allow: bool) -> Self {
        self.config.allow_allocation = allow;
        self
    }
    
    /// Set allocation delay
    pub fn with_allocation_delay(mut self, delay: Duration) -> Self {
        self.config.allocation_delay = Some(delay);
        self
    }
    
    /// Enable call tracking
    pub fn track_calls(mut self) -> Self {
        self.config.track_calls = true;
        self
    }
    
    /// Set error on allocate
    pub fn error_on_allocate(mut self, error: ColumnError) -> Self {
        self.config.error_on_allocate = Some(error);
        self
    }
    
    /// Set initial state
    pub fn with_state(mut self, state: ColumnState) -> Self {
        self.initial_state = state;
        self
    }
    
    /// Set initial activation
    pub fn with_activation(mut self, activation: f32) -> Self {
        self.initial_activation = activation;
        self
    }
    
    /// Build the mock column
    pub fn build(self) -> MockSpikingColumn {
        let mock = MockSpikingColumn::with_config(self.id, self.config);
        *mock.state.lock().unwrap() = self.initial_state;
        *mock.activation.lock().unwrap() = self.initial_activation;
        mock
    }
}

/// Test helper functions
pub mod helpers {
    use super::*;
    
    /// Create a pre-allocated column
    pub fn allocated_column(id: ColumnId, concept_name: &str) -> MockSpikingColumn {
        let column = MockColumnBuilder::new(id)
            .with_state(ColumnState::Allocated)
            .allow_allocation(false)
            .build();
        
        let concept_name = concept_name.to_string();
        *column.allocated_concept.lock().unwrap() = Some(concept_name.clone());
        
        column
    }
    
    /// Create an active column ready for allocation
    pub fn active_column(id: ColumnId) -> MockSpikingColumn {
        MockColumnBuilder::new(id)
            .with_state(ColumnState::Activated)
            .with_activation(0.8)
            .build()
    }
    
    /// Create a column that will fail allocation
    pub fn failing_column(id: ColumnId) -> MockSpikingColumn {
        MockColumnBuilder::new(id)
            .error_on_allocate(ColumnError::InhibitionBlocked)
            .build()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::helpers::*;
    
    #[test]
    fn test_mock_basic_behavior() {
        let column = MockSpikingColumn::new(1);
        
        assert_eq!(column.id(), 1);
        assert_eq!(column.state(), ColumnState::Available);
        assert_eq!(column.activation_level(), 0.0);
        
        // Test activation
        assert!(column.activate(0.8).is_ok());
        assert_eq!(column.state(), ColumnState::Activated);
        assert_eq!(column.activation_level(), 0.8);
    }
    
    #[test]
    fn test_mock_allocation() {
        let column = MockColumnBuilder::new(1)
            .track_calls()
            .build();
        
        let concept_name = "test".to_string();
        
        assert!(column.activate(0.9).is_ok());
        assert!(column.try_allocate(concept_name.clone()).is_ok());
        assert_eq!(column.state(), ColumnState::Allocated);
        assert_eq!(column.allocated_concept(), Some(concept_name));
        
        // Check call history
        let history = column.call_history();
        assert!(history.contains(&"activate".to_string()));
        assert!(history.contains(&"try_allocate".to_string()));
    }
    
    #[test]
    fn test_mock_configuration() {
        let column = MockColumnBuilder::new(1)
            .with_fixed_activation(0.9)
            .allow_allocation(false)
            .build();
        
        assert_eq!(column.activation_level(), 0.9);
        
        let concept_name = "test".to_string();
        assert!(column.try_allocate(concept_name).is_err());
    }
    
    #[test]
    fn test_helpers() {
        let allocated = allocated_column(1, "test");
        assert_eq!(allocated.state(), ColumnState::Allocated);
        assert!(allocated.allocated_concept().is_some());
        
        let active = active_column(2);
        assert_eq!(active.state(), ColumnState::Activated);
        assert!(active.activation_level() > 0.0);
        
        let failing = failing_column(3);
        let concept_name = "test".to_string();
        assert!(failing.try_allocate(concept_name).is_err());
    }
}
```

3. Create placeholder files for other mocks:
   touch src/mock_ttfs_allocator.rs
   touch src/mock_inhibition.rs
   touch src/mock_simd.rs

   Add to each:
   ```rust
   //! Mock implementation of [component name]
   
   // TODO: Implement in next micro-phase
   ```

4. Run tests:
   cd crates/snn-mocks
   cargo test

All tests should pass.
```

## Success Criteria
- [ ] MockSpikingColumn implements same interface
- [ ] Configurable behavior through MockConfig
- [ ] Builder pattern for easy test setup
- [ ] Helper functions for common scenarios
- [ ] Call tracking for test verification

## CLAUDE.md Synchronization Requirement
**CRITICAL**: After implementing mock infrastructure, verify that any existing `claude.md` files in the snn-mocks crate directory accurately reflect the new mock implementations. Update documentation if:
- Mock interfaces differ from documented real component interfaces
- Mock behavior configuration options change from documented capabilities
- Test utility methods differ from documented testing approaches
- Mock-to-real transition procedures change from documented processes