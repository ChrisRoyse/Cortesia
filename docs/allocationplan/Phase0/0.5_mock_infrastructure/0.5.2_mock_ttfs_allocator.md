# Micro-Phase 0.5.2: Create Mock TTFS Allocator

## Objective
Implement mock TTFS allocator for testing the allocation engine without real neural processing.

## Prerequisites
- Mock SNN column created (0.5.1 complete)
- Understanding of TTFS allocation interface

## Input
- TTFS allocation interface requirements
- Testing scenarios for allocation
- Performance simulation needs

## Task Details

### Step 1: Define Mock Allocator Interface
Create mock that simulates TTFS allocation behavior.

### Step 2: Add Allocation Scenarios
Implement different allocation patterns for testing.

### Step 3: Create Performance Simulation
Add configurable delays and throughput limits.

### Step 4: Implement Failure Modes
Add ability to simulate various failure scenarios.

## Expected Output
- `src/mock_ttfs_allocator.rs` implemented
- Multiple allocation scenarios
- Performance simulation capabilities
- Failure mode testing

## Verification Steps
1. Run `cargo test mock_ttfs` tests
2. Verify allocation scenarios work
3. Check performance simulation
4. Confirm failure modes trigger correctly

## Time Estimate
30-40 minutes

## AI Execution Prompt
```
DEPENDENCY ISSUE RESOLVED: This micro-phase originally had forward references to TTFSConcept 
and AllocationResult which aren't defined until Phase 0.3. 

Create a simplified placeholder mock that can be fully implemented after Phase 0.3:

1. Create src/mock_ttfs_allocator.rs content:

```rust
//! Mock implementation of TTFS allocator - Phase 0 simplified version
//! 
//! NOTE: This is a simplified mock for Phase 0. Full implementation 
//! will be available after TTFSConcept is defined in Phase 0.3.

use neuromorphic_core::spiking_column::ColumnId;
use std::collections::HashMap;
use std::time::Duration;

/// Simple allocation result for Phase 0 testing
#[derive(Debug, Clone)]
pub struct SimpleAllocationResult {
    pub column_id: Option<ColumnId>,
    pub success: bool,
    pub reason: String,
}

/// Phase 0 mock allocator working with concept names
pub struct MockTTFSAllocator {
    allocated_concepts: HashMap<String, ColumnId>,
    next_column_id: ColumnId,
    success_rate: f32,
}

impl Default for MockTTFSAllocator {
    fn default() -> Self {
        Self {
            allocated_concepts: HashMap::new(),
            next_column_id: 1,
            success_rate: 0.95,
        }
    }
}

impl MockTTFSAllocator {
    /// Create new mock allocator
    pub fn new() -> Self {
        Self::default()
    }
    
    /// Allocate a concept by name (simplified for Phase 0)
    pub fn allocate(&mut self, concept_name: &str) -> SimpleAllocationResult {
        // Check if already allocated
        if self.allocated_concepts.contains_key(concept_name) {
            return SimpleAllocationResult {
                column_id: None,
                success: false,
                reason: format!("Concept '{}' already allocated", concept_name),
            };
        }
        
        // Simulate success/failure
        if rand::random::<f32>() < self.success_rate {
            let column_id = self.next_column_id;
            self.next_column_id += 1;
            
            self.allocated_concepts.insert(concept_name.to_string(), column_id);
            
            SimpleAllocationResult {
                column_id: Some(column_id),
                success: true,
                reason: format!("Successfully allocated '{}' to column {}", concept_name, column_id),
            }
        } else {
            SimpleAllocationResult {
                column_id: None,
                success: false,
                reason: "Simulated allocation failure".to_string(),
            }
        }
    }
    
    /// Get column ID for a concept name
    pub fn get_column_for_concept(&self, concept_name: &str) -> Option<ColumnId> {
        self.allocated_concepts.get(concept_name).copied()
    }
    
    /// Clear all allocations
    pub fn clear(&mut self) {
        self.allocated_concepts.clear();
        self.next_column_id = 1;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_basic_allocation() {
        let mut allocator = MockTTFSAllocator::new();
        
        let result = allocator.allocate("test_concept");
        
        // Should succeed most of the time (95% success rate)
        if result.success {
            assert!(result.column_id.is_some());
            assert_eq!(result.column_id, Some(1));
            
            // Check that it was stored
            assert_eq!(allocator.get_column_for_concept("test_concept"), Some(1));
        }
    }
    
    #[test]
    fn test_duplicate_allocation() {
        let mut allocator = MockTTFSAllocator::new();
        
        // First allocation
        let result1 = allocator.allocate("test");
        if result1.success {
            // Second allocation should fail
            let result2 = allocator.allocate("test");
            assert!(!result2.success);
            assert!(result2.reason.contains("already allocated"));
        }
    }
    
    #[test]
    fn test_multiple_concepts() {
        let mut allocator = MockTTFSAllocator::new();
        
        let concepts = vec!["dog", "cat", "bird"];
        let mut allocated_columns = Vec::new();
        
        for concept in concepts {
            let result = allocator.allocate(concept);
            if result.success {
                allocated_columns.push(result.column_id.unwrap());
            }
        }
        
        // All successful allocations should have unique column IDs
        allocated_columns.sort();
        allocated_columns.dedup();
        // Length should be same as before dedup (no duplicates)
    }
    
    #[test]
    fn test_clear() {
        let mut allocator = MockTTFSAllocator::new();
        
        let _ = allocator.allocate("test");
        allocator.clear();
        
        // Should be able to allocate again after clear
        let result = allocator.allocate("test");
        // Might succeed or fail due to randomness, but shouldn't fail due to duplicate
        if !result.success {
            assert!(!result.reason.contains("already allocated"));
        }
    }
}
```

2. Update Cargo.toml to add rand dependency:
   Add to [dependencies]:
   rand = "0.8"

3. Run tests:
   cd crates/snn-mocks
   cargo test mock_ttfs
```
    pub avg_allocation_time: Duration,
    
    /// Allocation time variance (as percentage)
    pub time_variance: f32,
    
    /// Whether to use deterministic allocation
    pub deterministic: bool,
    
    /// Fixed column ID to return (if deterministic)
    pub fixed_column_id: Option<ColumnId>,
    
    /// Whether to track allocation history
    pub track_history: bool,
    
    /// Similarity threshold for duplicate detection
    pub similarity_threshold: f32,
}

impl Default for MockAllocatorConfig {
    fn default() -> Self {
        Self {
            success_rate: 0.95,
            avg_allocation_time: Duration::from_millis(5),
            time_variance: 0.2,
            deterministic: false,
            fixed_column_id: None,
            track_history: false,
            similarity_threshold: 0.9,
        }
    }
}

/// Mock TTFS allocator for testing
pub struct MockTTFSAllocator {
    config: MockAllocatorConfig,
    allocation_history: Arc<Mutex<Vec<AllocationRecord>>>,
    concept_store: Arc<Mutex<HashMap<ColumnId, TTFSConcept>>>,
    next_column_id: Arc<Mutex<ColumnId>>,
    similarity_calculator: ConceptSimilarity,
}

/// Record of an allocation attempt
#[derive(Debug, Clone)]
pub struct AllocationRecord {
    pub concept: TTFSConcept,
    pub result: AllocationResult,
    pub timestamp: Instant,
    pub duration: Duration,
}

/// Result of mock allocation
#[derive(Debug, Clone)]
pub struct AllocationResult {
    pub column_id: Option<ColumnId>,
    pub success: bool,
    pub reason: String,
    pub similar_concepts: Vec<(ColumnId, f32)>,
}

impl MockTTFSAllocator {
    /// Create new mock allocator
    pub fn new(config: MockAllocatorConfig) -> Self {
        Self {
            config,
            allocation_history: Arc::new(Mutex::new(Vec::new())),
            concept_store: Arc::new(Mutex::new(HashMap::new())),
            next_column_id: Arc::new(Mutex::new(1)),
            similarity_calculator: ConceptSimilarity::new(SimilarityConfig::default()),
        }
    }
    
    /// Create with default config
    pub fn default() -> Self {
        Self::new(MockAllocatorConfig::default())
    }
    
    /// Allocate a concept
    pub fn allocate(&self, concept: TTFSConcept) -> AllocationResult {
        let start = Instant::now();
        
        // Simulate allocation time
        let allocation_time = self.simulate_allocation_time();
        std::thread::sleep(allocation_time);
        
        // Check for duplicates
        let similar_concepts = self.find_similar_concepts(&concept);
        
        // Determine if allocation succeeds
        let (column_id, success, reason) = if self.should_succeed() {
            if let Some((existing_id, similarity)) = similar_concepts.first() {
                if *similarity > self.config.similarity_threshold {
                    (None, false, format!("Duplicate concept detected (similarity: {:.2})", similarity))
                } else {
                    let id = self.get_next_column_id();
                    self.store_concept(id, concept.clone());
                    (Some(id), true, "Allocation successful".to_string())
                }
            } else {
                let id = self.get_next_column_id();
                self.store_concept(id, concept.clone());
                (Some(id), true, "Allocation successful".to_string())
            }
        } else {
            (None, false, "Simulated allocation failure".to_string())
        };
        
        let result = AllocationResult {
            column_id,
            success,
            reason,
            similar_concepts,
        };
        
        // Track history if enabled
        if self.config.track_history {
            let record = AllocationRecord {
                concept,
                result: result.clone(),
                timestamp: Instant::now(),
                duration: start.elapsed(),
            };
            
            self.allocation_history.lock().unwrap().push(record);
        }
        
        result
    }
    
    /// Batch allocate multiple concepts
    pub fn allocate_batch(&self, concepts: Vec<TTFSConcept>) -> Vec<AllocationResult> {
        concepts.into_iter()
            .map(|concept| self.allocate(concept))
            .collect()
    }
    
    /// Find similar concepts
    fn find_similar_concepts(&self, concept: &TTFSConcept) -> Vec<(ColumnId, f32)> {
        let store = self.concept_store.lock().unwrap();
        
        let mut similarities: Vec<_> = store.iter()
            .map(|(&column_id, stored_concept)| {
                let similarity = self.similarity_calculator.similarity(concept, stored_concept);
                (column_id, similarity)
            })
            .filter(|(_, sim)| *sim > 0.5) // Only return meaningful similarities
            .collect();
        
        similarities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        similarities
    }
    
    /// Determine if allocation should succeed
    fn should_succeed(&self) -> bool {
        if self.config.deterministic {
            true
        } else {
            rand::thread_rng().gen::<f32>() < self.config.success_rate
        }
    }
    
    /// Simulate allocation time with variance
    fn simulate_allocation_time(&self) -> Duration {
        if self.config.deterministic {
            self.config.avg_allocation_time
        } else {
            let mut rng = rand::thread_rng();
            let variance = self.config.time_variance;
            let multiplier = 1.0 + rng.gen_range(-variance..variance);
            
            let millis = self.config.avg_allocation_time.as_millis() as f32 * multiplier;
            Duration::from_millis(millis as u64)
        }
    }
    
    /// Get next column ID
    fn get_next_column_id(&self) -> ColumnId {
        if let Some(fixed_id) = self.config.fixed_column_id {
            fixed_id
        } else {
            let mut next_id = self.next_column_id.lock().unwrap();
            let id = *next_id;
            *next_id += 1;
            id
        }
    }
    
    /// Store concept in internal map
    fn store_concept(&self, column_id: ColumnId, concept: TTFSConcept) {
        self.concept_store.lock().unwrap().insert(column_id, concept);
    }
    
    /// Get allocation history
    pub fn history(&self) -> Vec<AllocationRecord> {
        self.allocation_history.lock().unwrap().clone()
    }
    
    /// Clear allocation history
    pub fn clear_history(&self) {
        self.allocation_history.lock().unwrap().clear();
        self.concept_store.lock().unwrap().clear();
        *self.next_column_id.lock().unwrap() = 1;
    }
    
    /// Get allocation statistics
    pub fn stats(&self) -> AllocationStats {
        let history = self.allocation_history.lock().unwrap();
        
        let total = history.len();
        let successful = history.iter().filter(|r| r.result.success).count();
        
        let avg_duration = if total > 0 {
            let total_millis: u128 = history.iter()
                .map(|r| r.duration.as_millis())
                .sum();
            Duration::from_millis((total_millis / total as u128) as u64)
        } else {
            Duration::ZERO
        };
        
        AllocationStats {
            total_allocations: total,
            successful_allocations: successful,
            success_rate: if total > 0 { successful as f32 / total as f32 } else { 0.0 },
            average_duration: avg_duration,
            unique_concepts: self.concept_store.lock().unwrap().len(),
        }
    }
}

/// Statistics about allocations
#[derive(Debug, Clone)]
pub struct AllocationStats {
    pub total_allocations: usize,
    pub successful_allocations: usize,
    pub success_rate: f32,
    pub average_duration: Duration,
    pub unique_concepts: usize,
}

/// Builder for creating test scenarios
pub struct MockAllocatorBuilder {
    config: MockAllocatorConfig,
}

impl MockAllocatorBuilder {
    /// Create new builder
    pub fn new() -> Self {
        Self {
            config: MockAllocatorConfig::default(),
        }
    }
    
    /// Create high-performance scenario
    pub fn high_performance() -> Self {
        Self {
            config: MockAllocatorConfig {
                success_rate: 0.99,
                avg_allocation_time: Duration::from_millis(1),
                time_variance: 0.1,
                ..Default::default()
            },
        }
    }
    
    /// Create degraded performance scenario
    pub fn degraded_performance() -> Self {
        Self {
            config: MockAllocatorConfig {
                success_rate: 0.8,
                avg_allocation_time: Duration::from_millis(20),
                time_variance: 0.5,
                ..Default::default()
            },
        }
    }
    
    /// Create failure scenario
    pub fn high_failure_rate() -> Self {
        Self {
            config: MockAllocatorConfig {
                success_rate: 0.3,
                avg_allocation_time: Duration::from_millis(10),
                ..Default::default()
            },
        }
    }
    
    /// Set success rate
    pub fn with_success_rate(mut self, rate: f32) -> Self {
        self.config.success_rate = rate.clamp(0.0, 1.0);
        self
    }
    
    /// Set allocation time
    pub fn with_allocation_time(mut self, time: Duration) -> Self {
        self.config.avg_allocation_time = time;
        self
    }
    
    /// Enable history tracking
    pub fn track_history(mut self) -> Self {
        self.config.track_history = true;
        self
    }
    
    /// Make deterministic
    pub fn deterministic(mut self) -> Self {
        self.config.deterministic = true;
        self
    }
    
    /// Build allocator
    pub fn build(self) -> MockTTFSAllocator {
        MockTTFSAllocator::new(self.config)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    // ConceptBuilder will be available in Phase 0.3
    
    #[test]
    fn test_basic_allocation() {
        let allocator = MockTTFSAllocator::default();
        
        let concept = ConceptBuilder::new()
            .name("test")
            .features(vec![0.5; 32])
            .build()
            .unwrap();
        
        let result = allocator.allocate(concept);
        
        // Default config has 95% success rate
        // This test might occasionally fail due to randomness
        assert!(result.success || !result.success);
        
        if result.success {
            assert!(result.column_id.is_some());
        }
    }
    
    #[test]
    fn test_deterministic_allocation() {
        let allocator = MockAllocatorBuilder::new()
            .deterministic()
            .with_success_rate(1.0)
            .build();
        
        let concept = ConceptBuilder::new()
            .name("test")
            .features(vec![0.5; 32])
            .build()
            .unwrap();
        
        // Should always succeed
        for _ in 0..10 {
            let result = allocator.allocate(concept.clone());
            assert!(result.success);
            assert!(result.column_id.is_some());
        }
    }
    
    #[test]
    fn test_duplicate_detection() {
        let allocator = MockAllocatorBuilder::new()
            .deterministic()
            .build();
        
        let concept1 = ConceptBuilder::new()
            .name("dog")
            .features(vec![0.8; 32])
            .build()
            .unwrap();
        
        let concept2 = ConceptBuilder::new()
            .name("dog")
            .features(vec![0.8; 32]) // Same features
            .build()
            .unwrap();
        
        let result1 = allocator.allocate(concept1);
        assert!(result1.success);
        
        let result2 = allocator.allocate(concept2);
        assert!(!result2.success);
        assert!(result2.reason.contains("Duplicate"));
    }
    
    #[test]
    fn test_allocation_stats() {
        let allocator = MockAllocatorBuilder::new()
            .track_history()
            .deterministic()
            .with_success_rate(0.8)
            .build();
        
        // Allocate 10 concepts
        for i in 0..10 {
            let concept = ConceptBuilder::new()
                .name(&format!("concept_{}", i))
                .features(vec![i as f32 / 10.0; 32])
                .build()
                .unwrap();
            
            allocator.allocate(concept);
        }
        
        let stats = allocator.stats();
        assert_eq!(stats.total_allocations, 10);
        // With 80% success rate, expect ~8 successes
        assert!(stats.successful_allocations >= 6 && stats.successful_allocations <= 10);
    }
}
```

2. Update src/mock_ttfs_allocator.rs imports in lib.rs if needed.

3. Create a stub for AllocationResult in snn-allocation-engine if it doesn't exist yet:
   
   In snn-allocation-engine/src/lib.rs:
   ```rust
   pub mod snn_allocator {
       #[derive(Debug, Clone)]
       pub struct AllocationResult {
           pub column_id: Option<u32>,
           pub success: bool,
           pub reason: String,
           pub similar_concepts: Vec<(u32, f32)>,
       }
   }
   ```

4. Run tests:
   cd crates/snn-mocks
   cargo test mock_ttfs

All tests should pass.
```

## Success Criteria
- [ ] Mock allocator with configurable behavior
- [ ] Performance simulation with variance
- [ ] Duplicate detection functionality
- [ ] Statistics tracking
- [ ] Test scenario builders