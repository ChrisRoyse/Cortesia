# Micro-Phase 0.5.3: Create Mock Lateral Inhibition

## Objective
Implement mock lateral inhibition network for testing winner-take-all dynamics without real neural competition.

## Prerequisites
- Mock infrastructure started (0.5.1-0.5.2 complete)
- Understanding of lateral inhibition interface

## Input
- Lateral inhibition network interface
- Winner-take-all testing requirements
- Competition simulation needs

## Task Details

### Step 1: Create Mock Inhibition Network
Implement mock version of LateralInhibitionNetwork.

### Step 2: Add Competition Scenarios
Create different competition patterns for testing.

### Step 3: Implement Deterministic Competition
Add predictable winner selection for tests.

### Step 4: Create Inhibition Patterns
Simulate various inhibition spreading patterns.

## Expected Output
- `src/mock_inhibition.rs` implemented
- Competition scenario simulation
- Deterministic winner selection
- Configurable inhibition patterns

## Verification Steps
1. Run `cargo test mock_inhibition` tests
2. Verify competition scenarios work
3. Check deterministic mode
4. Confirm inhibition patterns apply correctly

## Time Estimate
30-35 minutes

## AI Execution Prompt
```
Implement mock lateral inhibition for testing.

1. Replace src/mock_inhibition.rs content:

```rust
//! Mock implementation of lateral inhibition network

use neuromorphic_core::spiking_column::{ColumnId, InhibitoryWeight};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use rand::Rng;

/// Configuration for mock lateral inhibition
#[derive(Debug, Clone)]
pub struct MockInhibitionConfig {
    /// Whether to use deterministic winner selection
    pub deterministic: bool,
    
    /// Fixed winner ID (if deterministic)
    pub fixed_winner: Option<ColumnId>,
    
    /// Base inhibition strength
    pub base_inhibition: f32,
    
    /// Inhibition decay with distance
    pub distance_decay: f32,
    
    /// Inhibition radius
    pub inhibition_radius: f32,
    
    /// Track competition history
    pub track_history: bool,
    
    /// Competition noise level
    pub noise_level: f32,
}

impl Default for MockInhibitionConfig {
    fn default() -> Self {
        Self {
            deterministic: false,
            fixed_winner: None,
            base_inhibition: 0.8,
            distance_decay: 0.3,
            inhibition_radius: 3.0,
            track_history: false,
            noise_level: 0.1,
        }
    }
}

/// Mock lateral inhibition network
pub struct MockLateralInhibition {
    config: MockInhibitionConfig,
    inhibition_state: Arc<Mutex<HashMap<ColumnId, f32>>>,
    competition_history: Arc<Mutex<Vec<CompetitionRecord>>>,
    column_positions: Arc<Mutex<HashMap<ColumnId, (f32, f32, f32)>>>,
}

/// Record of a competition
#[derive(Debug, Clone)]
pub struct CompetitionRecord {
    pub candidates: Vec<(ColumnId, f32)>,
    pub winner: ColumnId,
    pub inhibited: Vec<ColumnId>,
    pub timestamp: std::time::Instant,
}

/// Result of winner-take-all competition
#[derive(Debug, Clone)]
pub struct MockCompetitionResult {
    pub winner_id: ColumnId,
    pub winner_activation: f32,
    pub suppressed_columns: Vec<ColumnId>,
    pub inhibition_pattern: HashMap<ColumnId, f32>,
}

impl MockLateralInhibition {
    /// Create new mock inhibition network
    pub fn new(config: MockInhibitionConfig) -> Self {
        Self {
            config,
            inhibition_state: Arc::new(Mutex::new(HashMap::new())),
            competition_history: Arc::new(Mutex::new(Vec::new())),
            column_positions: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    /// Create with default config
    pub fn default() -> Self {
        Self::new(MockInhibitionConfig::default())
    }
    
    /// Register column position
    pub fn register_column(&self, id: ColumnId, position: (f32, f32, f32)) {
        self.column_positions.lock().unwrap().insert(id, position);
    }
    
    /// Run winner-take-all competition
    pub fn compete(&self, candidates: Vec<(ColumnId, f32)>) -> MockCompetitionResult {
        let start = std::time::Instant::now();
        
        // Apply noise if configured
        let candidates = if self.config.noise_level > 0.0 && !self.config.deterministic {
            self.apply_noise(candidates)
        } else {
            candidates
        };
        
        // Select winner
        let winner = if self.config.deterministic {
            if let Some(fixed_id) = self.config.fixed_winner {
                candidates.iter()
                    .find(|(id, _)| *id == fixed_id)
                    .unwrap_or(&candidates[0])
                    .clone()
            } else {
                // Deterministic: always pick highest activation
                candidates.iter()
                    .max_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
                    .unwrap()
                    .clone()
            }
        } else {
            // Stochastic: probabilistic selection based on activation
            self.stochastic_selection(&candidates)
        };
        
        // Apply inhibition to losers
        let mut inhibition_pattern = HashMap::new();
        let mut suppressed = Vec::new();
        
        for (id, activation) in &candidates {
            if *id != winner.0 {
                let inhibition = self.calculate_inhibition(winner.0, *id, winner.1);
                if inhibition > 0.0 {
                    inhibition_pattern.insert(*id, inhibition);
                    self.apply_inhibition(*id, inhibition);
                    suppressed.push(*id);
                }
            }
        }
        
        // Record history if enabled
        if self.config.track_history {
            let record = CompetitionRecord {
                candidates: candidates.clone(),
                winner: winner.0,
                inhibited: suppressed.clone(),
                timestamp: start,
            };
            self.competition_history.lock().unwrap().push(record);
        }
        
        MockCompetitionResult {
            winner_id: winner.0,
            winner_activation: winner.1,
            suppressed_columns: suppressed,
            inhibition_pattern,
        }
    }
    
    /// Apply noise to activations
    fn apply_noise(&self, candidates: Vec<(ColumnId, f32)>) -> Vec<(ColumnId, f32)> {
        let mut rng = rand::thread_rng();
        
        candidates.into_iter()
            .map(|(id, activation)| {
                let noise = rng.gen_range(-self.config.noise_level..self.config.noise_level);
                let noisy_activation = (activation + noise).clamp(0.0, 1.0);
                (id, noisy_activation)
            })
            .collect()
    }
    
    /// Stochastic winner selection
    fn stochastic_selection(&self, candidates: &[(ColumnId, f32)]) -> (ColumnId, f32) {
        let mut rng = rand::thread_rng();
        
        // Calculate selection probabilities (softmax-like)
        let sum: f32 = candidates.iter().map(|(_, a)| a.exp()).sum();
        let probabilities: Vec<f32> = candidates.iter()
            .map(|(_, a)| a.exp() / sum)
            .collect();
        
        // Select based on probabilities
        let random_val = rng.gen::<f32>();
        let mut cumulative = 0.0;
        
        for (i, prob) in probabilities.iter().enumerate() {
            cumulative += prob;
            if random_val <= cumulative {
                return candidates[i];
            }
        }
        
        // Fallback to last candidate
        candidates.last().unwrap().clone()
    }
    
    /// Calculate inhibition strength
    fn calculate_inhibition(&self, winner_id: ColumnId, target_id: ColumnId, winner_activation: f32) -> f32 {
        let positions = self.column_positions.lock().unwrap();
        
        // Calculate based on distance if positions are known
        if let (Some(winner_pos), Some(target_pos)) = (positions.get(&winner_id), positions.get(&target_id)) {
            let distance = Self::calculate_distance(*winner_pos, *target_pos);
            
            if distance <= self.config.inhibition_radius {
                let decay = 1.0 - (distance / self.config.inhibition_radius) * self.config.distance_decay;
                self.config.base_inhibition * winner_activation * decay
            } else {
                0.0
            }
        } else {
            // No position info: use base inhibition
            self.config.base_inhibition * winner_activation
        }
    }
    
    /// Calculate 3D distance
    fn calculate_distance(pos1: (f32, f32, f32), pos2: (f32, f32, f32)) -> f32 {
        let dx = pos1.0 - pos2.0;
        let dy = pos1.1 - pos2.1;
        let dz = pos1.2 - pos2.2;
        (dx * dx + dy * dy + dz * dz).sqrt()
    }
    
    /// Apply inhibition to a column
    pub fn apply_inhibition(&self, column_id: ColumnId, strength: f32) {
        let mut state = self.inhibition_state.lock().unwrap();
        let current = state.get(&column_id).unwrap_or(&0.0);
        state.insert(column_id, (*current + strength).min(1.0));
    }
    
    /// Get current inhibition level
    pub fn get_inhibition(&self, column_id: ColumnId) -> f32 {
        self.inhibition_state.lock().unwrap()
            .get(&column_id)
            .cloned()
            .unwrap_or(0.0)
    }
    
    /// Clear all inhibition
    pub fn clear_inhibition(&self) {
        self.inhibition_state.lock().unwrap().clear();
    }
    
    /// Get competition history
    pub fn history(&self) -> Vec<CompetitionRecord> {
        self.competition_history.lock().unwrap().clone()
    }
    
    /// Clear history
    pub fn clear_history(&self) {
        self.competition_history.lock().unwrap().clear();
    }
    
    /// Get competition statistics
    pub fn stats(&self) -> CompetitionStats {
        let history = self.competition_history.lock().unwrap();
        
        if history.is_empty() {
            return CompetitionStats::default();
        }
        
        let mut winner_counts = HashMap::new();
        let mut total_candidates = 0;
        let mut total_inhibited = 0;
        
        for record in history.iter() {
            *winner_counts.entry(record.winner).or_insert(0) += 1;
            total_candidates += record.candidates.len();
            total_inhibited += record.inhibited.len();
        }
        
        let most_wins = winner_counts.values().max().cloned().unwrap_or(0);
        let dominant_winner = winner_counts.iter()
            .find(|(_, &count)| count == most_wins)
            .map(|(&id, _)| id);
        
        CompetitionStats {
            total_competitions: history.len(),
            unique_winners: winner_counts.len(),
            dominant_winner,
            avg_candidates: total_candidates as f32 / history.len() as f32,
            avg_inhibited: total_inhibited as f32 / history.len() as f32,
        }
    }
}

/// Competition statistics
#[derive(Debug, Default)]
pub struct CompetitionStats {
    pub total_competitions: usize,
    pub unique_winners: usize,
    pub dominant_winner: Option<ColumnId>,
    pub avg_candidates: f32,
    pub avg_inhibited: f32,
}

/// Builder for test scenarios
pub struct MockInhibitionBuilder {
    config: MockInhibitionConfig,
}

impl MockInhibitionBuilder {
    /// Create new builder
    pub fn new() -> Self {
        Self {
            config: MockInhibitionConfig::default(),
        }
    }
    
    /// Create deterministic scenario
    pub fn deterministic() -> Self {
        Self {
            config: MockInhibitionConfig {
                deterministic: true,
                noise_level: 0.0,
                ..Default::default()
            },
        }
    }
    
    /// Create with fixed winner
    pub fn with_fixed_winner(mut self, winner_id: ColumnId) -> Self {
        self.config.deterministic = true;
        self.config.fixed_winner = Some(winner_id);
        self
    }
    
    /// Create noisy competition
    pub fn noisy(noise_level: f32) -> Self {
        Self {
            config: MockInhibitionConfig {
                noise_level,
                ..Default::default()
            },
        }
    }
    
    /// Set inhibition parameters
    pub fn with_inhibition(mut self, base: f32, decay: f32, radius: f32) -> Self {
        self.config.base_inhibition = base;
        self.config.distance_decay = decay;
        self.config.inhibition_radius = radius;
        self
    }
    
    /// Enable history tracking
    pub fn track_history(mut self) -> Self {
        self.config.track_history = true;
        self
    }
    
    /// Build the mock
    pub fn build(self) -> MockLateralInhibition {
        MockLateralInhibition::new(self.config)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_deterministic_competition() {
        let inhibition = MockInhibitionBuilder::deterministic()
            .track_history()
            .build();
        
        let candidates = vec![
            (1, 0.6),
            (2, 0.9), // Should always win
            (3, 0.7),
        ];
        
        // Run multiple times
        for _ in 0..5 {
            let result = inhibition.compete(candidates.clone());
            assert_eq!(result.winner_id, 2);
            assert_eq!(result.winner_activation, 0.9);
        }
        
        let stats = inhibition.stats();
        assert_eq!(stats.total_competitions, 5);
        assert_eq!(stats.unique_winners, 1);
        assert_eq!(stats.dominant_winner, Some(2));
    }
    
    #[test]
    fn test_fixed_winner() {
        let inhibition = MockInhibitionBuilder::new()
            .with_fixed_winner(3)
            .build();
        
        let candidates = vec![
            (1, 0.9), // Higher activation
            (2, 0.8),
            (3, 0.5), // Fixed winner despite low activation
        ];
        
        let result = inhibition.compete(candidates);
        assert_eq!(result.winner_id, 3);
    }
    
    #[test]
    fn test_spatial_inhibition() {
        let inhibition = MockInhibitionBuilder::new()
            .deterministic()
            .with_inhibition(0.8, 0.5, 2.0)
            .build();
        
        // Register positions
        inhibition.register_column(1, (0.0, 0.0, 0.0));
        inhibition.register_column(2, (1.0, 0.0, 0.0)); // Close
        inhibition.register_column(3, (3.0, 0.0, 0.0)); // Far
        
        let candidates = vec![
            (1, 0.9), // Winner
            (2, 0.7),
            (3, 0.7),
        ];
        
        let result = inhibition.compete(candidates);
        
        // Column 2 should be more inhibited than column 3
        assert!(result.inhibition_pattern[&2] > result.inhibition_pattern.get(&3).unwrap_or(&0.0));
    }
    
    #[test]
    fn test_noisy_competition() {
        let inhibition = MockInhibitionBuilder::noisy(0.2)
            .track_history()
            .build();
        
        let candidates = vec![
            (1, 0.7),
            (2, 0.75), // Close activations with noise
            (3, 0.73),
        ];
        
        // Run multiple times
        for _ in 0..20 {
            inhibition.compete(candidates.clone());
        }
        
        let stats = inhibition.stats();
        // With noise, should see multiple winners
        assert!(stats.unique_winners > 1);
    }
}
```

2. Run tests:
   cd crates/snn-mocks
   cargo test mock_inhibition

All tests should pass.
```

## Success Criteria
- [ ] Mock lateral inhibition network implemented
- [ ] Deterministic and stochastic competition modes
- [ ] Spatial inhibition with distance decay
- [ ] Competition history tracking
- [ ] Test scenario builders