# Micro-Phase 0.4.1: Define Memory Branch Types

## Objective
Define the neuromorphic memory branch types and consolidation states for temporal memory management.

## Prerequisites
- temporal-memory crate created (0.1.3 complete)
- Understanding of memory consolidation concepts

## Input
- Memory branch specifications from Phase 0
- Consolidation state requirements
- Version control needs

## Task Details

### Step 1: Define Branch Metadata
Create structures for tracking branch creation and relationships.

### Step 2: Implement Consolidation States
Define the states a memory branch can be in during consolidation.

### Step 3: Create Branch Identity
Add unique identification and versioning for branches.

### Step 4: Implement Branch Relationships
Enable parent-child and sibling relationships between branches.

## Expected Output
- `src/branch/mod.rs` and related files created
- Branch types and states defined
- Relationship tracking implemented
- Tests passing

## Verification Steps
1. Run `cargo test branch` in temporal-memory crate
2. Verify state transitions are valid
3. Check branch relationships work correctly
4. Confirm metadata is properly tracked

## Time Estimate
30-40 minutes

## AI Execution Prompt
```
Define memory branch types for the temporal-memory crate.

1. Create the module structure:
   cd crates/temporal-memory
   mkdir -p src/branch
   touch src/branch/mod.rs
   touch src/branch/types.rs
   touch src/branch/state.rs

2. Update src/lib.rs:
```rust
//! Temporal memory management
//! 
//! Handles memory branches and consolidation states.

pub mod branch;
pub mod consolidation;

pub use branch::{MemoryBranch, BranchId, BranchMetadata, ConsolidationState};
```

3. Create src/branch/mod.rs:
```rust
//! Memory branch management for temporal versioning

pub mod types;
pub mod state;

pub use types::{MemoryBranch, BranchId, BranchMetadata, BranchRelationship};
pub use state::{ConsolidationState, StateTransition};

use std::time::Duration;

/// Configuration for memory branches
#[derive(Debug, Clone)]
pub struct BranchConfig {
    /// Maximum age before consolidation required
    pub max_age: Duration,
    
    /// Maximum divergence from parent
    pub max_divergence: f32,
    
    /// Auto-consolidation threshold
    pub auto_consolidate_threshold: f32,
    
    /// Enable conflict detection
    pub detect_conflicts: bool,
}

impl Default for BranchConfig {
    fn default() -> Self {
        Self {
            max_age: Duration::from_secs(86400), // 24 hours
            max_divergence: 0.3,
            auto_consolidate_threshold: 0.8,
            detect_conflicts: true,
        }
    }
}
```

4. Implement src/branch/types.rs:
```rust
//! Core types for memory branches

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;
use chrono::{DateTime, Utc};

/// Unique identifier for a memory branch
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct BranchId(pub Uuid);

impl BranchId {
    /// Create a new branch ID
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

impl Default for BranchId {
    fn default() -> Self {
        Self::new()
    }
}

/// A memory branch representing a version of knowledge
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryBranch {
    /// Unique identifier
    pub id: BranchId,
    
    /// Human-readable name
    pub name: String,
    
    /// Branch metadata
    pub metadata: BranchMetadata,
    
    /// Parent branch ID (if any)
    pub parent_id: Option<BranchId>,
    
    /// Child branch IDs
    pub children: Vec<BranchId>,
    
    /// Consolidation state
    pub state: super::ConsolidationState,
    
    /// Branch-specific data
    pub data: BranchData,
}

/// Metadata about a memory branch
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BranchMetadata {
    /// Creation timestamp
    pub created_at: DateTime<Utc>,
    
    /// Last modification timestamp
    pub modified_at: DateTime<Utc>,
    
    /// Version number
    pub version: u32,
    
    /// Creator/source of the branch
    pub source: String,
    
    /// Description of branch purpose
    pub description: String,
    
    /// Tags for categorization
    pub tags: Vec<String>,
    
    /// Custom properties
    pub properties: HashMap<String, String>,
}

/// Data stored in a memory branch
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BranchData {
    /// Concept IDs in this branch
    pub concept_ids: Vec<Uuid>,
    
    /// Number of allocations
    pub allocation_count: usize,
    
    /// Divergence score from parent
    pub divergence: f32,
    
    /// Confidence score
    pub confidence: f32,
    
    /// Spike pattern signatures
    pub spike_signatures: Vec<SpikeSignature>,
}

/// Compressed spike pattern signature
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpikeSignature {
    /// Hash of the spike pattern
    pub hash: u64,
    
    /// Timestamp when recorded
    pub timestamp: DateTime<Utc>,
    
    /// Average spike rate
    pub avg_rate: f32,
    
    /// Pattern complexity
    pub complexity: f32,
}

/// Relationship between branches
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum BranchRelationship {
    /// Direct parent-child relationship
    Parent,
    
    /// Direct child of parent
    Child,
    
    /// Share same parent
    Sibling,
    
    /// Ancestor relationship
    Ancestor(u32), // generations removed
    
    /// Descendant relationship
    Descendant(u32), // generations removed
    
    /// No direct relationship
    Unrelated,
}

impl MemoryBranch {
    /// Create a new memory branch
    pub fn new(name: impl Into<String>) -> Self {
        let now = Utc::now();
        
        Self {
            id: BranchId::new(),
            name: name.into(),
            metadata: BranchMetadata {
                created_at: now,
                modified_at: now,
                version: 1,
                source: "manual".to_string(),
                description: String::new(),
                tags: Vec::new(),
                properties: HashMap::new(),
            },
            parent_id: None,
            children: Vec::new(),
            state: super::ConsolidationState::Active,
            data: BranchData {
                concept_ids: Vec::new(),
                allocation_count: 0,
                divergence: 0.0,
                confidence: 1.0,
                spike_signatures: Vec::new(),
            },
        }
    }
    
    /// Create a child branch
    pub fn create_child(&mut self, name: impl Into<String>) -> MemoryBranch {
        let mut child = Self::new(name);
        child.parent_id = Some(self.id);
        child.metadata.source = format!("branched from {}", self.name);
        
        // Copy some parent data
        child.data.concept_ids = self.data.concept_ids.clone();
        child.metadata.tags = self.metadata.tags.clone();
        
        // Add to parent's children
        self.children.push(child.id);
        
        child
    }
    
    /// Calculate relationship to another branch
    pub fn relationship_to(&self, other: &MemoryBranch) -> BranchRelationship {
        // Direct relationships
        if self.parent_id == Some(other.id) {
            return BranchRelationship::Child;
        }
        
        if other.parent_id == Some(self.id) {
            return BranchRelationship::Parent;
        }
        
        // Sibling check
        if let (Some(p1), Some(p2)) = (self.parent_id, other.parent_id) {
            if p1 == p2 {
                return BranchRelationship::Sibling;
            }
        }
        
        // TODO: Implement ancestor/descendant traversal
        
        BranchRelationship::Unrelated
    }
    
    /// Update modification timestamp
    pub fn touch(&mut self) {
        self.metadata.modified_at = Utc::now();
    }
    
    /// Add a concept to this branch
    pub fn add_concept(&mut self, concept_id: Uuid) {
        if !self.data.concept_ids.contains(&concept_id) {
            self.data.concept_ids.push(concept_id);
            self.data.allocation_count += 1;
            self.touch();
        }
    }
    
    /// Calculate age of the branch
    pub fn age(&self) -> chrono::Duration {
        Utc::now() - self.metadata.created_at
    }
}

impl Default for BranchMetadata {
    fn default() -> Self {
        let now = Utc::now();
        Self {
            created_at: now,
            modified_at: now,
            version: 1,
            source: "unknown".to_string(),
            description: String::new(),
            tags: Vec::new(),
            properties: HashMap::new(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_branch_creation() {
        let branch = MemoryBranch::new("test_branch");
        
        assert_eq!(branch.name, "test_branch");
        assert!(branch.parent_id.is_none());
        assert!(branch.children.is_empty());
        assert_eq!(branch.metadata.version, 1);
    }
    
    #[test]
    fn test_child_branch() {
        let mut parent = MemoryBranch::new("parent");
        let child = parent.create_child("child");
        
        assert_eq!(child.parent_id, Some(parent.id));
        assert!(parent.children.contains(&child.id));
        assert_eq!(child.relationship_to(&parent), BranchRelationship::Child);
        assert_eq!(parent.relationship_to(&child), BranchRelationship::Parent);
    }
    
    #[test]
    fn test_sibling_relationship() {
        let mut parent = MemoryBranch::new("parent");
        let child1 = parent.create_child("child1");
        let child2 = parent.create_child("child2");
        
        assert_eq!(child1.relationship_to(&child2), BranchRelationship::Sibling);
        assert_eq!(child2.relationship_to(&child1), BranchRelationship::Sibling);
    }
    
    #[test]
    fn test_concept_addition() {
        let mut branch = MemoryBranch::new("test");
        let concept_id = Uuid::new_v4();
        
        branch.add_concept(concept_id);
        assert!(branch.data.concept_ids.contains(&concept_id));
        assert_eq!(branch.data.allocation_count, 1);
        
        // Adding same concept again shouldn't duplicate
        branch.add_concept(concept_id);
        assert_eq!(branch.data.concept_ids.len(), 1);
        assert_eq!(branch.data.allocation_count, 1);
    }
}
```

5. Add dependencies to temporal-memory Cargo.toml:
   uuid = { workspace = true }
   chrono = { workspace = true }
   serde = { workspace = true }

6. Create placeholder for state.rs:
```rust
//! Consolidation state management

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ConsolidationState {
    Active,
    Consolidating,
    Consolidated,
    Conflicted,
}

pub struct StateTransition;
```

7. Run tests:
   cd crates/temporal-memory
   cargo test branch

All tests should pass.
```

## Success Criteria
- [ ] BranchId type with UUID support
- [ ] MemoryBranch with full metadata
- [ ] Parent-child relationships working
- [ ] Sibling detection functional
- [ ] Concept tracking in branches