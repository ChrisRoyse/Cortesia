# Micro-Phase 0.4.3: Implement Branch Manager

## Objective
Create a branch manager that handles the lifecycle of memory branches including creation, traversal, and consolidation orchestration.

## Prerequisites
- Memory branch types defined (0.4.1 complete)
- Consolidation state machine implemented (0.4.2 complete)

## Input
- Branch lifecycle requirements
- Tree traversal algorithms
- Performance requirements for branch operations

## Task Details

### Step 1: Implement Branch Repository
Create storage and retrieval system for branches.

### Step 2: Add Tree Traversal Methods
Implement methods to navigate branch hierarchy.

### Step 3: Create Branch Operations
Add merge, split, and prune operations.

### Step 4: Implement Event System
Add events for branch lifecycle changes.

## Expected Output
- `src/branch/manager.rs` file created
- Branch repository with CRUD operations
- Tree traversal algorithms
- Event notification system
- Tests demonstrating usage

## Verification Steps
1. Run `cargo test manager` tests
2. Verify branch creation and retrieval
3. Check tree traversal works correctly
4. Confirm events fire on state changes

## Time Estimate
40-50 minutes

## AI Execution Prompt
```
Implement the branch manager for temporal memory.

1. Create src/branch/manager.rs:

```rust
//! Branch lifecycle management

use super::{MemoryBranch, BranchId, BranchConfig, ConsolidationState};
use crate::consolidation::{ConsolidationEngine, ConsolidationConfig, ConsolidationResult};
use dashmap::DashMap;
use parking_lot::RwLock;
use std::sync::Arc;
use thiserror::Error;
use tokio::sync::broadcast;

/// Events emitted by the branch manager
#[derive(Debug, Clone)]
pub enum BranchEvent {
    /// Branch was created
    Created { branch_id: BranchId, parent_id: Option<BranchId> },
    
    /// Branch state changed
    StateChanged { branch_id: BranchId, from: ConsolidationState, to: ConsolidationState },
    
    /// Branch was consolidated
    Consolidated { parent_id: BranchId, child_id: BranchId },
    
    /// Branch was pruned
    Pruned { branch_id: BranchId },
    
    /// Concept allocated to branch
    ConceptAllocated { branch_id: BranchId, concept_id: uuid::Uuid },
}

/// Errors that can occur in branch management
#[derive(Error, Debug)]
pub enum BranchError {
    #[error("Branch not found: {0:?}")]
    NotFound(BranchId),
    
    #[error("Invalid parent branch: {0:?}")]
    InvalidParent(BranchId),
    
    #[error("Circular dependency detected")]
    CircularDependency,
    
    #[error("Branch is not active: {0:?}")]
    NotActive(BranchId),
    
    #[error("Consolidation failed: {0}")]
    ConsolidationFailed(String),
    
    #[error("Operation not allowed in current state")]
    InvalidOperation,
}

/// Manages the lifecycle of memory branches
pub struct BranchManager {
    /// Configuration
    config: BranchConfig,
    
    /// Branch storage
    branches: DashMap<BranchId, Arc<RwLock<MemoryBranch>>>,
    
    /// Root branch ID
    root_id: BranchId,
    
    /// Consolidation engine
    consolidation_engine: ConsolidationEngine,
    
    /// Event channel
    event_sender: broadcast::Sender<BranchEvent>,
    
    /// Statistics
    stats: RwLock<BranchStats>,
}

/// Statistics about branch operations
#[derive(Debug, Default)]
struct BranchStats {
    total_branches: usize,
    active_branches: usize,
    consolidated_branches: usize,
    total_concepts: usize,
    consolidation_attempts: usize,
    successful_consolidations: usize,
}

impl BranchManager {
    /// Create new branch manager
    pub fn new(config: BranchConfig) -> Self {
        let root = MemoryBranch::new("root");
        let root_id = root.id;
        
        let mut branches = DashMap::new();
        branches.insert(root_id, Arc::new(RwLock::new(root)));
        
        let (event_sender, _) = broadcast::channel(1000);
        
        Self {
            config,
            branches,
            root_id,
            consolidation_engine: ConsolidationEngine::new(ConsolidationConfig::default()),
            event_sender,
            stats: RwLock::new(BranchStats {
                total_branches: 1,
                active_branches: 1,
                ..Default::default()
            }),
        }
    }
    
    /// Get event receiver
    pub fn subscribe(&self) -> broadcast::Receiver<BranchEvent> {
        self.event_sender.subscribe()
    }
    
    /// Get root branch ID
    pub fn root_id(&self) -> BranchId {
        self.root_id
    }
    
    /// Create a new branch
    pub fn create_branch(&self, 
                        name: impl Into<String>, 
                        parent_id: Option<BranchId>) -> Result<BranchId, BranchError> {
        let parent_id = parent_id.unwrap_or(self.root_id);
        
        // Get parent branch
        let parent_arc = self.branches.get(&parent_id)
            .ok_or(BranchError::InvalidParent(parent_id))?;
        
        let mut parent = parent_arc.write();
        
        // Create child branch
        let child = parent.create_child(name);
        let child_id = child.id;
        
        // Store child
        self.branches.insert(child_id, Arc::new(RwLock::new(child)));
        
        // Update stats
        {
            let mut stats = self.stats.write();
            stats.total_branches += 1;
            stats.active_branches += 1;
        }
        
        // Emit event
        let _ = self.event_sender.send(BranchEvent::Created {
            branch_id: child_id,
            parent_id: Some(parent_id),
        });
        
        Ok(child_id)
    }
    
    /// Get a branch by ID
    pub fn get_branch(&self, id: BranchId) -> Option<Arc<RwLock<MemoryBranch>>> {
        self.branches.get(&id).map(|b| b.clone())
    }
    
    /// List all branches
    pub fn list_branches(&self) -> Vec<BranchId> {
        self.branches.iter()
            .map(|entry| *entry.key())
            .collect()
    }
    
    /// Find branches by state
    pub fn find_by_state(&self, state: ConsolidationState) -> Vec<BranchId> {
        self.branches.iter()
            .filter(|entry| entry.value().read().state == state)
            .map(|entry| *entry.key())
            .collect()
    }
    
    /// Get branch ancestry (path from root to branch)
    pub fn get_ancestry(&self, branch_id: BranchId) -> Result<Vec<BranchId>, BranchError> {
        let mut ancestry = Vec::new();
        let mut current_id = Some(branch_id);
        let mut visited = std::collections::HashSet::new();
        
        while let Some(id) = current_id {
            // Detect cycles
            if !visited.insert(id) {
                return Err(BranchError::CircularDependency);
            }
            
            ancestry.push(id);
            
            let branch = self.get_branch(id)
                .ok_or(BranchError::NotFound(id))?;
            
            current_id = branch.read().parent_id;
        }
        
        ancestry.reverse(); // Root first
        Ok(ancestry)
    }
    
    /// Get all descendants of a branch
    pub fn get_descendants(&self, branch_id: BranchId) -> Result<Vec<BranchId>, BranchError> {
        let mut descendants = Vec::new();
        let mut to_visit = vec![branch_id];
        
        while let Some(current_id) = to_visit.pop() {
            let branch = self.get_branch(current_id)
                .ok_or(BranchError::NotFound(current_id))?;
            
            let children = branch.read().children.clone();
            
            for child_id in children {
                descendants.push(child_id);
                to_visit.push(child_id);
            }
        }
        
        Ok(descendants)
    }
    
    /// Allocate a concept to a branch
    pub fn allocate_concept(&self, 
                           branch_id: BranchId, 
                           concept_id: uuid::Uuid) -> Result<(), BranchError> {
        let branch = self.get_branch(branch_id)
            .ok_or(BranchError::NotFound(branch_id))?;
        
        let mut branch_write = branch.write();
        
        // Check if branch can accept allocations
        if branch_write.state != ConsolidationState::Active {
            return Err(BranchError::NotActive(branch_id));
        }
        
        branch_write.add_concept(concept_id);
        
        // Update stats
        self.stats.write().total_concepts += 1;
        
        // Emit event
        let _ = self.event_sender.send(BranchEvent::ConceptAllocated {
            branch_id,
            concept_id,
        });
        
        Ok(())
    }
    
    /// Start consolidation of a branch into its parent
    pub async fn consolidate_branch(&self, branch_id: BranchId) -> Result<ConsolidationResult, BranchError> {
        let branch = self.get_branch(branch_id)
            .ok_or(BranchError::NotFound(branch_id))?;
        
        let parent_id = {
            let b = branch.read();
            b.parent_id.ok_or(BranchError::InvalidOperation)?
        };
        
        let parent = self.get_branch(parent_id)
            .ok_or(BranchError::NotFound(parent_id))?;
        
        // Update state to consolidating
        self.update_branch_state(branch_id, ConsolidationState::Consolidating)?;
        
        // Perform consolidation
        let result = {
            let parent_read = parent.read();
            let child_read = branch.read();
            
            self.consolidation_engine.consolidate(&*parent_read, &*child_read)
                .map_err(|e| BranchError::ConsolidationFailed(e.to_string()))?
        };
        
        // Update state based on result
        if result.success {
            self.update_branch_state(branch_id, ConsolidationState::Consolidated)?;
            
            // Update stats
            let mut stats = self.stats.write();
            stats.consolidation_attempts += 1;
            stats.successful_consolidations += 1;
            stats.active_branches -= 1;
            stats.consolidated_branches += 1;
            
            // Emit event
            let _ = self.event_sender.send(BranchEvent::Consolidated {
                parent_id,
                child_id: branch_id,
            });
        } else {
            self.update_branch_state(branch_id, ConsolidationState::Conflicted)?;
            
            self.stats.write().consolidation_attempts += 1;
        }
        
        Ok(result)
    }
    
    /// Update branch state
    fn update_branch_state(&self, 
                          branch_id: BranchId, 
                          new_state: ConsolidationState) -> Result<(), BranchError> {
        let branch = self.get_branch(branch_id)
            .ok_or(BranchError::NotFound(branch_id))?;
        
        let mut branch_write = branch.write();
        let old_state = branch_write.state;
        
        // Use state machine to validate transition
        use crate::branch::state::StateTransition;
        let mut state_machine = StateTransition::new(old_state);
        
        state_machine.transition_to(new_state, "Manager update".to_string())
            .map_err(|_| BranchError::InvalidOperation)?;
        
        branch_write.state = new_state;
        branch_write.touch();
        
        // Emit event
        let _ = self.event_sender.send(BranchEvent::StateChanged {
            branch_id,
            from: old_state,
            to: new_state,
        });
        
        Ok(())
    }
    
    /// Prune old consolidated branches
    pub fn prune_consolidated(&self, max_age: chrono::Duration) -> Vec<BranchId> {
        let mut pruned = Vec::new();
        
        let to_prune: Vec<_> = self.branches.iter()
            .filter(|entry| {
                let branch = entry.value().read();
                branch.state == ConsolidationState::Consolidated &&
                branch.age() > max_age
            })
            .map(|entry| *entry.key())
            .collect();
        
        for branch_id in to_prune {
            if let Some((_, branch)) = self.branches.remove(&branch_id) {
                // Remove from parent's children
                if let Some(parent_id) = branch.read().parent_id {
                    if let Some(parent) = self.get_branch(parent_id) {
                        let mut parent_write = parent.write();
                        parent_write.children.retain(|&id| id != branch_id);
                    }
                }
                
                pruned.push(branch_id);
                
                // Emit event
                let _ = self.event_sender.send(BranchEvent::Pruned { branch_id });
            }
        }
        
        // Update stats
        self.stats.write().total_branches -= pruned.len();
        
        pruned
    }
    
    /// Get branch statistics
    pub fn stats(&self) -> BranchStats {
        self.stats.read().clone()
    }
}

impl Clone for BranchStats {
    fn clone(&self) -> Self {
        Self {
            total_branches: self.total_branches,
            active_branches: self.active_branches,
            consolidated_branches: self.consolidated_branches,
            total_concepts: self.total_concepts,
            consolidation_attempts: self.consolidation_attempts,
            successful_consolidations: self.successful_consolidations,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_branch_creation() {
        let manager = BranchManager::new(BranchConfig::default());
        
        let branch1 = manager.create_branch("feature1", None).unwrap();
        let branch2 = manager.create_branch("feature2", Some(branch1)).unwrap();
        
        assert!(manager.get_branch(branch1).is_some());
        assert!(manager.get_branch(branch2).is_some());
        
        let stats = manager.stats();
        assert_eq!(stats.total_branches, 3); // root + 2 branches
        assert_eq!(stats.active_branches, 3);
    }
    
    #[test]
    fn test_ancestry_traversal() {
        let manager = BranchManager::new(BranchConfig::default());
        
        let branch1 = manager.create_branch("level1", None).unwrap();
        let branch2 = manager.create_branch("level2", Some(branch1)).unwrap();
        let branch3 = manager.create_branch("level3", Some(branch2)).unwrap();
        
        let ancestry = manager.get_ancestry(branch3).unwrap();
        
        assert_eq!(ancestry.len(), 4); // root -> branch1 -> branch2 -> branch3
        assert_eq!(ancestry[0], manager.root_id());
        assert_eq!(ancestry[3], branch3);
    }
    
    #[test]
    fn test_descendants_traversal() {
        let manager = BranchManager::new(BranchConfig::default());
        
        let parent = manager.create_branch("parent", None).unwrap();
        let child1 = manager.create_branch("child1", Some(parent)).unwrap();
        let child2 = manager.create_branch("child2", Some(parent)).unwrap();
        let grandchild = manager.create_branch("grandchild", Some(child1)).unwrap();
        
        let descendants = manager.get_descendants(parent).unwrap();
        
        assert_eq!(descendants.len(), 3);
        assert!(descendants.contains(&child1));
        assert!(descendants.contains(&child2));
        assert!(descendants.contains(&grandchild));
    }
    
    #[test]
    fn test_concept_allocation() {
        let manager = BranchManager::new(BranchConfig::default());
        let branch = manager.create_branch("test", None).unwrap();
        let concept_id = uuid::Uuid::new_v4();
        
        assert!(manager.allocate_concept(branch, concept_id).is_ok());
        
        let branch_ref = manager.get_branch(branch).unwrap();
        assert!(branch_ref.read().data.concept_ids.contains(&concept_id));
        
        assert_eq!(manager.stats().total_concepts, 1);
    }
}
```

2. Update src/branch/mod.rs to include manager:
```rust
//! Memory branch management for temporal versioning

pub mod types;
pub mod state;
pub mod manager;

pub use types::{MemoryBranch, BranchId, BranchMetadata, BranchRelationship};
pub use state::{ConsolidationState, StateTransition};
pub use manager::{BranchManager, BranchEvent, BranchError};

// ... rest of file ...
```

3. Add tokio dependency to temporal-memory Cargo.toml:
   tokio = { workspace = true }

4. Run tests:
   cd crates/temporal-memory
   cargo test manager

All tests should pass.
```

## Success Criteria
- [ ] Branch repository with CRUD operations
- [ ] Tree traversal (ancestry and descendants)
- [ ] Event system for lifecycle changes
- [ ] Consolidation orchestration working
- [ ] Statistics tracking implemented