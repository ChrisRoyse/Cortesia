# Micro-Phase 0.3.3: Create Concept Builder Pattern

## Objective
Implement a builder pattern for creating TTFS concepts with validation and feature extraction.

## Prerequisites
- TTFS concept types defined (0.3.1 complete)
- TTFS encoding implemented (0.3.2 complete)

## Input
- Builder pattern requirements
- Validation rules for concepts
- Feature extraction needs

## Task Details

### Step 1: Implement Concept Builder
Create fluent API for building concepts step by step.

### Step 2: Add Validation Rules
Ensure concepts meet all requirements before creation.

### Step 3: Create Feature Extractors
Add methods to extract features from text or properties.

### Step 4: Implement Batch Building
Enable efficient creation of multiple concepts.

## Expected Output
- `src/ttfs_concept/builder.rs` file created
- Builder pattern with validation
- Feature extraction utilities
- Tests demonstrating usage

## Verification Steps
1. Run `cargo test builder` tests
2. Verify fluent API is ergonomic
3. Check validation catches invalid concepts
4. Confirm batch operations are efficient

## Time Estimate
30-40 minutes

## AI Execution Prompt
```
Implement the concept builder pattern for TTFS concepts.

1. Create src/ttfs_concept/builder.rs:

```rust
//! Builder pattern for constructing TTFS concepts

use super::{TTFSConcept, ConceptMetadata, SpikePattern};
use super::encoding::{TTFSEncoder, EncodingConfig};
use uuid::Uuid;
use std::collections::HashMap;

/// Builder for creating TTFS concepts with validation
pub struct ConceptBuilder {
    name: Option<String>,
    semantic_features: Vec<f32>,
    parent_id: Option<Uuid>,
    properties: HashMap<String, String>,
    tags: Vec<String>,
    source: String,
    confidence: f32,
    encoder: TTFSEncoder,
}

impl Default for ConceptBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl ConceptBuilder {
    /// Create a new concept builder
    pub fn new() -> Self {
        Self {
            name: None,
            semantic_features: Vec::new(),
            parent_id: None,
            properties: HashMap::new(),
            tags: Vec::new(),
            source: "builder".to_string(),
            confidence: 1.0,
            encoder: TTFSEncoder::default(),
        }
    }
    
    /// Create builder with custom encoder
    pub fn with_encoder(encoder: TTFSEncoder) -> Self {
        Self {
            encoder,
            ..Self::new()
        }
    }
    
    /// Set concept name (required)
    pub fn name(mut self, name: impl Into<String>) -> Self {
        self.name = Some(name.into());
        self
    }
    
    /// Set semantic features directly
    pub fn features(mut self, features: Vec<f32>) -> Self {
        self.semantic_features = features;
        self
    }
    
    /// Extract features from text (placeholder - would use real NLP)
    pub fn features_from_text(mut self, text: &str) -> Self {
        // Simple feature extraction based on text characteristics
        let features = self.extract_text_features(text);
        self.semantic_features = features;
        self
    }
    
    /// Set parent concept
    pub fn parent(mut self, parent_id: Uuid) -> Self {
        self.parent_id = Some(parent_id);
        self
    }
    
    /// Add a property
    pub fn property(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.properties.insert(key.into(), value.into());
        self
    }
    
    /// Add multiple properties
    pub fn properties(mut self, props: HashMap<String, String>) -> Self {
        self.properties.extend(props);
        self
    }
    
    /// Add a tag
    pub fn tag(mut self, tag: impl Into<String>) -> Self {
        self.tags.push(tag.into());
        self
    }
    
    /// Add multiple tags
    pub fn tags(mut self, tags: Vec<String>) -> Self {
        self.tags.extend(tags);
        self
    }
    
    /// Set source
    pub fn source(mut self, source: impl Into<String>) -> Self {
        self.source = source.into();
        self
    }
    
    /// Set confidence
    pub fn confidence(mut self, confidence: f32) -> Self {
        self.confidence = confidence.clamp(0.0, 1.0);
        self
    }
    
    /// Build the concept
    pub fn build(self) -> Result<TTFSConcept, BuilderError> {
        // Validate required fields
        let name = self.name.ok_or(BuilderError::MissingName)?;
        
        // Generate features if not provided
        let features = if self.semantic_features.is_empty() {
            self.generate_default_features(&name)
        } else {
            self.semantic_features
        };
        
        // Validate features
        Self::validate_features(&features)?;
        
        // Encode to spike pattern
        let spike_pattern = self.encoder.encode(&features);
        
        // Create metadata
        let metadata = ConceptMetadata {
            source: self.source,
            confidence: self.confidence,
            parent_id: self.parent_id,
            properties: self.properties,
            tags: self.tags,
        };
        
        // Build concept
        let concept = TTFSConcept {
            id: Uuid::new_v4(),
            name,
            semantic_features: features,
            spike_pattern,
            metadata,
            created_at: chrono::Utc::now(),
        };
        
        Ok(concept)
    }
    
    /// Extract features from text (simplified version)
    fn extract_text_features(&self, text: &str) -> Vec<f32> {
        // This is a placeholder - real implementation would use NLP
        let mut features = vec![0.0; 128];
        
        // Simple heuristics for demo
        features[0] = (text.len() as f32 / 100.0).min(1.0); // Length feature
        features[1] = text.chars().filter(|c| c.is_uppercase()).count() as f32 / text.len() as f32;
        features[2] = text.split_whitespace().count() as f32 / 50.0;
        
        // Hash-based features for diversity
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        text.hash(&mut hasher);
        let hash = hasher.finish();
        
        for i in 3..features.len() {
            features[i] = ((hash >> (i % 64)) & 1) as f32 * 0.5 + 0.25;
        }
        
        features
    }
    
    /// Generate default features from name
    fn generate_default_features(&self, name: &str) -> Vec<f32> {
        self.extract_text_features(name)
    }
    
    /// Validate feature vector
    fn validate_features(features: &[f32]) -> Result<(), BuilderError> {
        if features.is_empty() {
            return Err(BuilderError::EmptyFeatures);
        }
        
        if features.len() > 1024 {
            return Err(BuilderError::TooManyFeatures(features.len()));
        }
        
        if features.iter().any(|&f| !f.is_finite()) {
            return Err(BuilderError::InvalidFeatureValue);
        }
        
        Ok(())
    }
}

/// Batch builder for creating multiple concepts efficiently
pub struct BatchConceptBuilder {
    encoder: TTFSEncoder,
    concepts: Vec<ConceptBuilder>,
}

impl BatchConceptBuilder {
    /// Create new batch builder
    pub fn new() -> Self {
        Self {
            encoder: TTFSEncoder::default(),
            concepts: Vec::new(),
        }
    }
    
    /// Add a concept to the batch
    pub fn add_concept<F>(mut self, configure: F) -> Self 
    where
        F: FnOnce(ConceptBuilder) -> ConceptBuilder,
    {
        let builder = ConceptBuilder::with_encoder(self.encoder.clone());
        let configured = configure(builder);
        self.concepts.push(configured);
        self
    }
    
    /// Build all concepts
    pub fn build_all(self) -> Result<Vec<TTFSConcept>, BatchBuilderError> {
        let mut results = Vec::new();
        let mut errors = Vec::new();
        
        for (idx, builder) in self.concepts.into_iter().enumerate() {
            match builder.build() {
                Ok(concept) => results.push(concept),
                Err(e) => errors.push((idx, e)),
            }
        }
        
        if errors.is_empty() {
            Ok(results)
        } else {
            Err(BatchBuilderError { errors })
        }
    }
}

/// Errors that can occur during building
#[derive(Debug, thiserror::Error)]
pub enum BuilderError {
    #[error("Concept name is required")]
    MissingName,
    
    #[error("Feature vector cannot be empty")]
    EmptyFeatures,
    
    #[error("Too many features: {0} (max 1024)")]
    TooManyFeatures(usize),
    
    #[error("Invalid feature value (NaN or infinity)")]
    InvalidFeatureValue,
}

/// Errors from batch building
#[derive(Debug, thiserror::Error)]
#[error("Batch building failed with {0} errors")]
pub struct BatchBuilderError {
    pub errors: Vec<(usize, BuilderError)>,
}

/// Derive Clone for TTFSEncoder to support batch building
impl Clone for TTFSEncoder {
    fn clone(&self) -> Self {
        Self::new(self.config.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_basic_builder() {
        let concept = ConceptBuilder::new()
            .name("dog")
            .features(vec![0.8; 64])
            .property("species", "Canis familiaris")
            .tag("animal")
            .tag("pet")
            .confidence(0.95)
            .build()
            .unwrap();
        
        assert_eq!(concept.name, "dog");
        assert_eq!(concept.semantic_features.len(), 64);
        assert_eq!(concept.metadata.properties["species"], "Canis familiaris");
        assert_eq!(concept.metadata.tags.len(), 2);
        assert_eq!(concept.metadata.confidence, 0.95);
    }
    
    #[test]
    fn test_feature_extraction() {
        let concept = ConceptBuilder::new()
            .name("artificial intelligence")
            .features_from_text("AI systems that learn from data")
            .build()
            .unwrap();
        
        assert!(!concept.semantic_features.is_empty());
        assert!(concept.spike_pattern.events.len() > 0);
    }
    
    #[test]
    fn test_validation() {
        // Missing name
        let result = ConceptBuilder::new()
            .features(vec![0.5; 10])
            .build();
        assert!(matches!(result, Err(BuilderError::MissingName)));
        
        // Empty features with no name to generate from
        let result = ConceptBuilder::new()
            .name("")
            .features(vec![])
            .build();
        assert!(matches!(result, Err(BuilderError::EmptyFeatures)));
        
        // Invalid feature values
        let result = ConceptBuilder::new()
            .name("test")
            .features(vec![f32::NAN])
            .build();
        assert!(matches!(result, Err(BuilderError::InvalidFeatureValue)));
    }
    
    #[test]
    fn test_parent_relationship() {
        let parent_id = Uuid::new_v4();
        
        let concept = ConceptBuilder::new()
            .name("puppy")
            .parent(parent_id)
            .features(vec![0.7; 32])
            .build()
            .unwrap();
        
        assert_eq!(concept.metadata.parent_id, Some(parent_id));
    }
    
    #[test]
    fn test_batch_builder() {
        let batch = BatchConceptBuilder::new()
            .add_concept(|b| b.name("cat").features(vec![0.6; 32]))
            .add_concept(|b| b.name("dog").features(vec![0.7; 32]))
            .add_concept(|b| b.name("bird").features(vec![0.5; 32]));
        
        let concepts = batch.build_all().unwrap();
        assert_eq!(concepts.len(), 3);
        assert_eq!(concepts[0].name, "cat");
        assert_eq!(concepts[1].name, "dog");
        assert_eq!(concepts[2].name, "bird");
    }
}
```

2. Update src/ttfs_concept/mod.rs to include builder:
```rust
//! TTFS-encoded concept representation

pub mod spike_pattern;
pub mod encoding;
pub mod builder;

// ... existing imports ...

pub use builder::{ConceptBuilder, BatchConceptBuilder};

// ... rest of file ...
```

3. Add derive Clone to EncodingConfig in encoding.rs:
   Find the EncodingConfig struct and update:
   ```rust
   #[derive(Debug, Clone)]
   pub struct EncodingConfig {
   ```

4. Run tests:
   cd crates/neuromorphic-core
   cargo test ttfs_concept::builder

All tests should pass.
```

## Success Criteria
- [ ] Fluent builder API implemented
- [ ] Validation prevents invalid concepts
- [ ] Feature extraction from text working
- [ ] Batch building efficient
- [ ] Parent-child relationships supported