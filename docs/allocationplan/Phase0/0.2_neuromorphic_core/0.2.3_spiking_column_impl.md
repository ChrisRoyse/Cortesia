# Micro-Phase 0.2.3: Complete SpikingCorticalColumn Implementation

## Objective
Implement the complete SpikingCorticalColumn struct that combines state machine, activation dynamics, and lateral connections.

## Prerequisites
- Column state machine implemented (0.2.1 complete)
- Activation dynamics implemented (0.2.2 complete)

## Input
- State and activation components
- Lateral connection requirements
- Thread-safety requirements

## Task Details

### Step 1: Define Core Column Structure
Create the main SpikingCorticalColumn struct with all components.

### Step 2: Implement Column Initialization
Add constructor and configuration methods.

### Step 3: Add Lateral Connections
Implement the lateral connection management system.

### Step 4: Create Allocation Methods
Add try_allocate and related allocation logic.

### Step 5: Implement Debug and Display
Add helpful debugging traits.

## Expected Output
- `src/spiking_column/column.rs` file created
- Complete SpikingCorticalColumn implementation
- Integration with state and activation
- All tests passing

## Verification Steps
1. Run `cargo test spiking_column` for all column tests
2. Verify thread-safe allocation works
3. Check lateral connections are managed correctly
4. Confirm state transitions during allocation

## Time Estimate
40-50 minutes

## AI Execution Prompt
```
Implement the complete SpikingCorticalColumn struct.

1. Create src/spiking_column/column.rs:

```rust
//! Complete spiking cortical column implementation

use super::{ColumnId, SpikeTiming, InhibitoryWeight, ColumnError};
use super::state::{ColumnState, AtomicState};
use super::activation::ActivationDynamics;

use std::sync::Arc;
use std::time::{Duration, Instant};
use dashmap::DashMap;
use parking_lot::RwLock;


/// A spiking cortical column with TTFS dynamics
pub struct SpikingCorticalColumn {
    /// Unique identifier
    id: ColumnId,
    
    /// Current state (atomic)
    state: AtomicState,
    
    /// Activation dynamics
    activation: ActivationDynamics,
    
    /// Currently allocated concept name (if any)
    allocated_concept: RwLock<Option<String>>,
    
    /// Lateral connections to other columns
    lateral_connections: DashMap<ColumnId, InhibitoryWeight>,
    
    /// Time of last spike
    last_spike_time: RwLock<Option<Instant>>,
    
    /// Allocation timestamp
    allocation_time: RwLock<Option<Instant>>,
    
    /// Metrics
    spike_count: std::sync::atomic::AtomicU64,
}

impl SpikingCorticalColumn {
    /// Create a new cortical column
    pub fn new(id: ColumnId) -> Self {
        Self {
            id,
            state: AtomicState::new(ColumnState::Available),
            activation: ActivationDynamics::new(),
            allocated_concept: RwLock::new(None),
            lateral_connections: DashMap::new(),
            last_spike_time: RwLock::new(None),
            allocation_time: RwLock::new(None),
            spike_count: std::sync::atomic::AtomicU64::new(0),
        }
    }
    
    /// Get column ID
    pub fn id(&self) -> ColumnId {
        self.id
    }
    
    /// Get current state
    pub fn state(&self) -> ColumnState {
        self.state.load()
    }
    
    /// Get current activation level
    pub fn activation_level(&self) -> f32 {
        self.activation.get_activation()
    }
    
    /// Activate the column with given strength
    pub fn activate(&self, strength: f32) -> Result<(), ColumnError> {
        // Transition to activated state
        match self.state.try_transition(ColumnState::Activated) {
            Ok(_) => {
                self.activation.set_activation(strength);
                Ok(())
            }
            Err(current_state) => {
                if current_state == ColumnState::Activated {
                    // Already activated, just update strength
                    self.activation.strengthen(strength);
                    Ok(())
                } else {
                    Err(ColumnError::InvalidTransition(current_state, ColumnState::Activated))
                }
            }
        }
    }
    
    /// Try to allocate this column to a concept
    pub fn try_allocate(&self, concept_name: String) -> Result<(), ColumnError> {
        // Check current state
        let current_state = self.state.load();
        
        match current_state {
            ColumnState::Allocated => return Err(ColumnError::AlreadyAllocated),
            ColumnState::Refractory => return Err(ColumnError::InRefractory),
            _ => {}
        }
        
        // Check if inhibited
        if self.is_inhibited() {
            return Err(ColumnError::InhibitionBlocked);
        }
        
        // Try to transition through states
        if current_state == ColumnState::Available {
            self.state.try_transition(ColumnState::Activated)
                .map_err(|s| ColumnError::InvalidTransition(s, ColumnState::Activated))?;
        }
        
        if self.state.load() == ColumnState::Activated {
            self.state.try_transition(ColumnState::Competing)
                .map_err(|s| ColumnError::InvalidTransition(s, ColumnState::Competing))?;
        }
        
        // Final transition to allocated
        self.state.try_transition(ColumnState::Allocated)
            .map_err(|s| ColumnError::InvalidTransition(s, ColumnState::Allocated))?;
        
        // Store the concept name
        *self.allocated_concept.write() = Some(concept_name);
        *self.allocation_time.write() = Some(Instant::now());
        
        Ok(())
    }
    
    /// Add a lateral connection to another column
    pub fn add_lateral_connection(&self, target: ColumnId, weight: InhibitoryWeight) {
        self.lateral_connections.insert(target, weight);
    }
    
    /// Get lateral connection weight to a target column
    pub fn connection_strength_to(&self, target: ColumnId) -> Option<InhibitoryWeight> {
        self.lateral_connections.get(&target).map(|w| *w)
    }
    
    /// Strengthen connection to another column (Hebbian learning)
    pub fn strengthen_connection(&self, target: ColumnId, correlation: f32) {
        self.lateral_connections.entry(target)
            .and_modify(|w| {
                // Hebbian update rule
                let delta = 0.1 * correlation * (1.0 - *w);
                *w = (*w + delta).clamp(0.0, 1.0);
            })
            .or_insert(0.1 * correlation);
    }
    
    /// Check if column should spike
    pub fn should_spike(&self) -> bool {
        self.activation.should_spike()
    }
    
    /// Process a spike event
    pub fn process_spike(&self) -> Option<SpikeTiming> {
        if self.should_spike() {
            let now = Instant::now();
            *self.last_spike_time.write() = Some(now);
            self.activation.record_spike();
            self.spike_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
            
            // Calculate time-to-first-spike if this is first spike after activation
            if self.spike_count.load(std::sync::atomic::Ordering::Relaxed) == 1 {
                if let Some(alloc_time) = *self.allocation_time.read() {
                    return Some(now.duration_since(alloc_time));
                }
            }
            
            Some(Duration::from_millis(0))
        } else {
            None
        }
    }
    
    /// Check if column is inhibited by lateral connections
    fn is_inhibited(&self) -> bool {
        // Simple inhibition check - can be made more sophisticated
        let total_inhibition: f32 = self.lateral_connections.iter()
            .map(|entry| *entry.value())
            .sum();
        
        total_inhibition > 0.8
    }
    
    /// Enter refractory period
    pub fn enter_refractory(&self) -> Result<(), ColumnError> {
        self.state.try_transition(ColumnState::Refractory)
            .map_err(|s| ColumnError::InvalidTransition(s, ColumnState::Refractory))?;
        
        // Reset activation during refractory
        self.activation.reset();
        Ok(())
    }
    
    /// Reset column to available state
    pub fn reset(&self) -> Result<(), ColumnError> {
        self.state.try_transition(ColumnState::Available)
            .map_err(|s| ColumnError::InvalidTransition(s, ColumnState::Available))?;
        
        *self.allocated_concept.write() = None;
        *self.allocation_time.write() = None;
        *self.last_spike_time.write() = None;
        self.activation.reset();
        self.spike_count.store(0, std::sync::atomic::Ordering::Relaxed);
        
        Ok(())
    }
    
    /// Get allocated concept name if any
    pub fn allocated_concept(&self) -> Option<String> {
        self.allocated_concept.read().clone()
    }
    
    /// Get spike count
    pub fn spike_count(&self) -> u64 {
        self.spike_count.load(std::sync::atomic::Ordering::Relaxed)
    }
}

impl std::fmt::Debug for SpikingCorticalColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SpikingCorticalColumn")
            .field("id", &self.id)
            .field("state", &self.state.load())
            .field("activation", &self.activation_level())
            .field("allocated", &self.allocated_concept.read().is_some())
            .field("spike_count", &self.spike_count())
            .finish()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use std::thread;
    
    #[test]
    fn test_column_lifecycle() {
        let column = SpikingCorticalColumn::new(1);
        
        // Initial state
        assert_eq!(column.state(), ColumnState::Available);
        assert_eq!(column.activation_level(), 0.0);
        
        // Activation
        assert!(column.activate(0.8).is_ok());
        assert_eq!(column.state(), ColumnState::Activated);
        assert!(column.activation_level() > 0.7);
        
        // Allocation
        let concept_name = "test".to_string();
        assert!(column.try_allocate(concept_name.clone()).is_ok());
        assert_eq!(column.state(), ColumnState::Allocated);
        assert_eq!(column.allocated_concept(), Some(concept_name));
        
        // Cannot double-allocate
        let concept2_name = "test2".to_string();
        assert!(matches!(
            column.try_allocate(concept2_name),
            Err(ColumnError::AlreadyAllocated)
        ));
        
        // Refractory and reset
        assert!(column.enter_refractory().is_ok());
        assert_eq!(column.state(), ColumnState::Refractory);
        
        assert!(column.reset().is_ok());
        assert_eq!(column.state(), ColumnState::Available);
        assert!(column.allocated_concept().is_none());
    }
    
    #[test]
    fn test_lateral_connections() {
        let column = SpikingCorticalColumn::new(1);
        
        // Add connections
        column.add_lateral_connection(2, 0.5);
        column.add_lateral_connection(3, 0.3);
        
        assert_eq!(column.connection_strength_to(2), Some(0.5));
        assert_eq!(column.connection_strength_to(3), Some(0.3));
        assert_eq!(column.connection_strength_to(4), None);
        
        // Strengthen connection
        column.strengthen_connection(2, 0.8);
        assert!(column.connection_strength_to(2).unwrap() > 0.5);
    }
    
    #[test]
    fn test_concurrent_allocation() {
        let column = Arc::new(SpikingCorticalColumn::new(1));
        column.activate(0.9).unwrap();
        
        let mut handles = vec![];
        
        // Spawn threads trying to allocate
        for i in 0..10 {
            let col = column.clone();
            handles.push(thread::spawn(move || {
                let concept_name = format!("concept_{}", i);
                col.try_allocate(concept_name)
            }));
        }
        
        let results: Vec<_> = handles.into_iter()
            .map(|h| h.join().unwrap())
            .collect();
        
        // Exactly one should succeed
        let successes = results.iter().filter(|r| r.is_ok()).count();
        assert_eq!(successes, 1);
        assert!(column.allocated_concept().is_some());
    }
}
```

2. Update src/spiking_column/mod.rs to include the column module:
```rust
//! Spiking cortical column implementation with TTFS dynamics

pub mod state;
pub mod activation; 
pub mod column;

pub use state::{ColumnState, AtomicState};
pub use activation::ActivationDynamics;
pub use column::SpikingCorticalColumn;

use std::time::Duration;

pub type ColumnId = u32;
pub type SpikeTiming = Duration;
pub type InhibitoryWeight = f32;
pub type RefractoryPeriod = Duration;
```

3. Run tests:
   cd crates/neuromorphic-core
   cargo test spiking_column

All tests should pass.
```

## Success Criteria
- [ ] Complete SpikingCorticalColumn struct implemented
- [ ] State transitions working during allocation
- [ ] Lateral connections managed properly
- [ ] Thread-safe concurrent allocation verified
- [ ] All integration tests passing

## CLAUDE.md Synchronization Requirement
**CRITICAL**: After implementing the SpikingCorticalColumn struct, verify that any existing `claude.md` files in the neuromorphic-core crate directory accurately reflect the new implementation. Update documentation if:
- The SpikingCorticalColumn API differs from documented interfaces
- State transition behavior changes from documented workflows
- Lateral connection management differs from documented patterns
- Thread-safety guarantees change from documented specifications
- Performance characteristics differ from documented benchmarks