# Micro-Phase 0.2.1: Define Spiking Column Types and State Machine

## Objective
Define the core types and state machine for the SpikingCorticalColumn implementation with atomic state transitions.

## Prerequisites
- neuromorphic-core crate created (0.1.2 complete)
- Basic Rust environment set up

## Input
- Phase 0 specification for column state machine
- TTFS encoding requirements

## Task Details

### Step 1: Define Type Aliases
Create neuromorphic-specific type aliases for clarity.

### Step 2: Implement Column State Enum
Define the state machine states with atomic representation.

### Step 3: Create Atomic State Wrapper
Implement thread-safe state transitions.

### Step 4: Write State Transition Tests
Create comprehensive tests for state machine behavior.

## Expected Output
- `src/spiking_column/state.rs` file created
- Types and enums defined
- Basic state transition logic implemented
- Tests passing

## Verification Steps
1. Run `cargo test` in neuromorphic-core crate
2. Verify state transitions are atomic
3. Check that invalid transitions are prevented
4. Confirm all states are reachable

## Time Estimate
30-40 minutes

## AI Execution Prompt
```
Create the spiking column state machine implementation in the neuromorphic-core crate.

1. Create the file structure:
   mkdir -p crates/neuromorphic-core/src/spiking_column
   touch crates/neuromorphic-core/src/spiking_column/mod.rs
   touch crates/neuromorphic-core/src/spiking_column/state.rs

2. In src/spiking_column/mod.rs add:
```rust
//! Spiking cortical column implementation with TTFS dynamics

pub mod state;

pub use state::{ColumnState, AtomicState};
pub use self::ColumnError;

use std::time::Duration;
use thiserror::Error;

pub type ColumnId = u32;
pub type SpikeTiming = Duration;
pub type InhibitoryWeight = f32;
pub type RefractoryPeriod = Duration;

/// Errors that can occur during column operations
#[derive(Error, Debug, Clone)]
pub enum ColumnError {
    #[error("Column already allocated")]
    AlreadyAllocated,
    
    #[error("Column in refractory period")]
    InRefractory,
    
    #[error("Invalid state transition from {0:?} to {1:?}")]
    InvalidTransition(ColumnState, ColumnState),
    
    #[error("Allocation blocked by lateral inhibition")]
    InhibitionBlocked,
}
```

3. Implement src/spiking_column/state.rs:
```rust
//! State machine for spiking cortical columns

use std::sync::atomic::{AtomicU8, Ordering};

/// States of a cortical column in the spiking neural network
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ColumnState {
    /// Column is available for allocation
    Available = 0,
    /// Column has been activated by input
    Activated = 1,
    /// Column is competing via lateral inhibition
    Competing = 2,
    /// Column has been allocated to a concept
    Allocated = 3,
    /// Column is in refractory period
    Refractory = 4,
}

impl ColumnState {
    /// Convert from u8 representation
    pub fn from_u8(value: u8) -> Self {
        match value {
            0 => Self::Available,
            1 => Self::Activated,
            2 => Self::Competing,
            3 => Self::Allocated,
            4 => Self::Refractory,
            _ => unreachable!("Invalid column state: {}", value),
        }
    }
    
    /// Check if transition to new state is valid
    pub fn can_transition_to(&self, new_state: ColumnState) -> bool {
        use ColumnState::*;
        match (*self, new_state) {
            // From Available
            (Available, Activated) => true,
            (Available, Available) => true,
            
            // From Activated  
            (Activated, Competing) => true,
            (Activated, Available) => true,
            
            // From Competing
            (Competing, Allocated) => true,
            (Competing, Available) => true,
            (Competing, Refractory) => true,
            
            // From Allocated
            (Allocated, Refractory) => true,
            (Allocated, Allocated) => true,
            
            // From Refractory
            (Refractory, Available) => true,
            (Refractory, Refractory) => true,
            
            // All other transitions invalid
            _ => false,
        }
    }
}

/// Thread-safe atomic state for cortical columns
pub struct AtomicState(AtomicU8);

impl AtomicState {
    /// Create new atomic state
    pub fn new(state: ColumnState) -> Self {
        Self(AtomicU8::new(state as u8))
    }
    
    /// Load current state
    pub fn load(&self) -> ColumnState {
        ColumnState::from_u8(self.0.load(Ordering::Acquire))
    }
    
    /// Store new state
    pub fn store(&self, state: ColumnState) {
        self.0.store(state as u8, Ordering::Release);
    }
    
    /// Atomic compare and exchange
    pub fn compare_exchange(
        &self,
        current: ColumnState,
        new: ColumnState,
    ) -> Result<ColumnState, ColumnState> {
        // Validate transition
        if !current.can_transition_to(new) {
            return Err(self.load());
        }
        
        match self.0.compare_exchange(
            current as u8,
            new as u8,
            Ordering::AcqRel,
            Ordering::Acquire,
        ) {
            Ok(v) => Ok(ColumnState::from_u8(v)),
            Err(v) => Err(ColumnState::from_u8(v)),
        }
    }
    
    /// Try to transition to new state
    pub fn try_transition(&self, new_state: ColumnState) -> Result<(), ColumnState> {
        let current = self.load();
        self.compare_exchange(current, new_state)?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use std::thread;
    
    #[test]
    fn test_state_transitions() {
        let state = AtomicState::new(ColumnState::Available);
        
        // Valid transition
        assert!(state.try_transition(ColumnState::Activated).is_ok());
        assert_eq!(state.load(), ColumnState::Activated);
        
        // Invalid transition
        assert!(state.try_transition(ColumnState::Allocated).is_err());
        assert_eq!(state.load(), ColumnState::Activated);
        
        // Valid multi-step
        assert!(state.try_transition(ColumnState::Competing).is_ok());
        assert!(state.try_transition(ColumnState::Allocated).is_ok());
        assert_eq!(state.load(), ColumnState::Allocated);
    }
    
    #[test]
    fn test_concurrent_state_access() {
        let state = Arc::new(AtomicState::new(ColumnState::Available));
        let mut handles = vec![];
        
        // Spawn 10 threads trying to activate
        for _ in 0..10 {
            let state_clone = state.clone();
            handles.push(thread::spawn(move || {
                state_clone.compare_exchange(
                    ColumnState::Available,
                    ColumnState::Activated
                )
            }));
        }
        
        let results: Vec<_> = handles.into_iter()
            .map(|h| h.join().unwrap())
            .collect();
        
        // Exactly one should succeed
        let successes = results.iter().filter(|r| r.is_ok()).count();
        assert_eq!(successes, 1);
        assert_eq!(state.load(), ColumnState::Activated);
    }
    
    #[test]
    fn test_state_machine_completeness() {
        // Verify all states are reachable
        let state = AtomicState::new(ColumnState::Available);
        
        // Path to Allocated
        assert!(state.try_transition(ColumnState::Activated).is_ok());
        assert!(state.try_transition(ColumnState::Competing).is_ok());
        assert!(state.try_transition(ColumnState::Allocated).is_ok());
        
        // Path to Refractory and back
        assert!(state.try_transition(ColumnState::Refractory).is_ok());
        assert!(state.try_transition(ColumnState::Available).is_ok());
    }
}
```

4. Update src/spiking_column.rs in the parent module:
```rust
//! Spiking cortical column implementation

pub mod state;
```

5. Run tests to verify implementation:
   cd crates/neuromorphic-core
   cargo test spiking_column::state

The tests should all pass, confirming the state machine is working correctly.
```

## Success Criteria
- [ ] State enum with 5 states defined
- [ ] AtomicState wrapper implemented
- [ ] State transition validation working
- [ ] All tests passing
- [ ] Thread-safe concurrent access verified