# Micro-Phase 0.7.5: Benchmark CLI Core Implementation

## Objective
Implement the core benchmark CLI tool and execution engine for automated performance testing.

## Prerequisites
- Benchmark framework implemented (0.6.1-0.6.3 complete)
- GitHub Actions workflows setup (0.7.1-0.7.4 complete)

## Input
- Benchmark framework from neuromorphic-benchmarks crate
- BenchmarkRunner infrastructure
- Performance thresholds and configurations

## Task Details

### Step 1: Create Main Benchmark CLI
Build the primary benchmark execution CLI tool with comprehensive options.

### Step 2: Implement BenchmarkRunner Core
Create the core benchmark execution engine with proper error handling.

### Step 3: Add Configuration Management
Implement flexible configuration system for benchmark parameters.

### Step 4: Create Output Management
Add result formatting, saving, and threshold validation.

## Expected Output
- `crates/neuromorphic-benchmarks/src/bin/benchmark.rs` implemented
- `crates/neuromorphic-benchmarks/src/runners.rs` core functionality
- Comprehensive CLI interface
- Automatic threshold checking

## Verification Steps
1. Build benchmark CLI tools locally
2. Run sample benchmarks
3. Verify output formatting
4. Test threshold validation

## Time Estimate
30-35 minutes

## AI Execution Prompt
```
Implement the core benchmark CLI tool and execution engine.

1. Create crates/neuromorphic-benchmarks/src/bin/benchmark.rs:

```rust
//! Main benchmark execution CLI tool

use clap::Parser;
use cortesia_benchmarks::prelude::*;
use cortesia_benchmarks::runners::BenchmarkRunner;
use serde_json;
use std::fs;
use std::path::PathBuf;
use std::time::Instant;

#[derive(Parser)]
#[command(name = "benchmark")]
#[command(about = "Run Cortesia performance benchmarks")]
struct Args {
    /// Type of benchmark to run
    #[arg(long, value_enum)]
    benchmark_type: BenchmarkType,
    
    /// Number of iterations
    #[arg(long, default_value = "1000")]
    iterations: usize,
    
    /// Number of warmup iterations
    #[arg(long, default_value = "100")]
    warmup_iterations: usize,
    
    /// Data size for benchmark
    #[arg(long, default_value = "100")]
    data_size: usize,
    
    /// Number of concurrent workers
    #[arg(long, default_value = "1")]
    concurrency: usize,
    
    /// Duration for stress tests (seconds)
    #[arg(long)]
    duration: Option<u64>,
    
    /// Output file for results
    #[arg(long)]
    output: Option<PathBuf>,
    
    /// Save detailed measurements
    #[arg(long)]
    save_details: bool,
    
    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    
    if args.verbose {
        env_logger::init();
    }
    
    println!("ðŸš€ Starting {} benchmark...", args.benchmark_type.description());
    println!("Configuration:");
    println!("  Iterations: {}", args.iterations);
    println!("  Warmup: {}", args.warmup_iterations);
    println!("  Data size: {}", args.data_size);
    println!("  Concurrency: {}", args.concurrency);
    if let Some(duration) = args.duration {
        println!("  Duration: {}s", duration);
    }
    println!();
    
    let config = BenchmarkConfig {
        benchmark_type: args.benchmark_type.clone(),
        iterations: args.iterations,
        warmup_iterations: args.warmup_iterations,
        data_size: args.data_size,
        concurrency: args.concurrency,
        duration: args.duration.map(std::time::Duration::from_secs),
        save_details: args.save_details,
        output_dir: args.output.as_ref().and_then(|p| p.parent()).map(|p| p.to_string_lossy().to_string()),
        ..Default::default()
    };
    
    let start_time = Instant::now();
    
    // Run benchmark
    let runner = BenchmarkRunner::new();
    let result = runner.run_benchmark(config)?;
    
    let total_time = start_time.elapsed();
    
    // Print results
    print_results(&result, total_time);
    
    // Save results if requested
    if let Some(output_path) = args.output {
        save_results(&result, &output_path)?;
        println!("âœ… Results saved to {}", output_path.display());
    }
    
    // Check if benchmark passed
    if result.passed {
        println!("ðŸŽ‰ Benchmark PASSED all performance thresholds!");
        Ok(())
    } else {
        println!("âš ï¸  Benchmark FAILED some performance thresholds:");
        for failure in &result.failures {
            println!("  - {}", failure);
        }
        std::process::exit(1);
    }
}

fn print_results(result: &BenchmarkResult, total_time: std::time::Duration) {
    println!("ðŸ“Š Benchmark Results:");
    println!("  Type: {}", result.config.benchmark_type.description());
    println!("  Status: {}", if result.passed { "âœ… PASSED" } else { "âŒ FAILED" });
    println!("  Total time: {:.2}s", total_time.as_secs_f64());
    println!();
    
    println!("Performance Metrics:");
    println!("  Average duration: {:.3}ms", result.metrics.avg_duration.as_secs_f64() * 1000.0);
    println!("  Median duration: {:.3}ms", result.metrics.median_duration.as_secs_f64() * 1000.0);
    println!("  95th percentile: {:.3}ms", result.metrics.p95_duration.as_secs_f64() * 1000.0);
    println!("  99th percentile: {:.3}ms", result.metrics.p99_duration.as_secs_f64() * 1000.0);
    println!("  Throughput: {:.2} ops/sec", result.metrics.throughput);
    println!("  Memory usage: {:.2} MB", result.metrics.memory_usage_mb);
    println!("  Peak memory: {:.2} MB", result.metrics.peak_memory_mb);
    println!("  Error rate: {:.2}%", result.metrics.error_rate * 100.0);
    println!("  Successful ops: {}", result.metrics.successful_ops);
    println!("  Failed ops: {}", result.metrics.failed_ops);
    
    if !result.metrics.custom_metrics.is_empty() {
        println!("Custom Metrics:");
        for (key, value) in &result.metrics.custom_metrics {
            println!("  {}: {:.3}", key, value);
        }
    }
}

fn save_results(result: &BenchmarkResult, path: &PathBuf) -> Result<(), Box<dyn std::error::Error>> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }
    
    let json = serde_json::to_string_pretty(result)?;
    fs::write(path, json)?;
    
    Ok(())
}
```

2. Create crates/neuromorphic-benchmarks/src/runners.rs:

```rust
//! Benchmark execution runners

use crate::types::*;
use crate::metrics::MetricsCollector;
use std::time::Instant;
use std::sync::Arc;
use std::thread;

/// Main benchmark runner
pub struct BenchmarkRunner {
    // Configuration and state
}

impl BenchmarkRunner {
    /// Create new benchmark runner
    pub fn new() -> Self {
        Self {}
    }
    
    /// Run a single benchmark
    pub fn run_benchmark(&self, config: BenchmarkConfig) -> Result<BenchmarkResult, BenchmarkError> {
        let start_time = Instant::now();
        
        println!("ðŸ”¥ Running {} warmup iterations...", config.warmup_iterations);
        
        // Warmup phase
        for _ in 0..config.warmup_iterations {
            self.execute_benchmark_iteration(&config)?;
        }
        
        println!("ðŸ“Š Running {} measurement iterations...", config.iterations);
        
        // Measurement phase
        let metrics_collector = MetricsCollector::new(config.clone());
        metrics_collector.start_collection();
        
        for i in 0..config.iterations {
            if i % (config.iterations / 10).max(1) == 0 {
                println!("  Progress: {}/{}", i, config.iterations);
            }
            
            let handle = metrics_collector.start_operation();
            match self.execute_benchmark_iteration(&config) {
                Ok(_) => handle.complete(),
                Err(_) => handle.fail(),
            }
        }
        
        let metrics = metrics_collector.finalize();
        
        // Check against thresholds
        let threshold = config.benchmark_type.target_threshold();
        let mut failures = Vec::new();
        let mut passed = true;
        
        if let Some(max_duration) = threshold.max_duration {
            if metrics.avg_duration > max_duration {
                failures.push(format!("Average duration {:.3}ms exceeds maximum {:.3}ms", 
                    metrics.avg_duration.as_secs_f64() * 1000.0,
                    max_duration.as_secs_f64() * 1000.0));
                passed = false;
            }
        }
        
        if let Some(min_throughput) = threshold.min_throughput {
            if metrics.throughput < min_throughput {
                failures.push(format!("Throughput {:.2} ops/sec below minimum {:.2} ops/sec",
                    metrics.throughput, min_throughput));
                passed = false;
            }
        }
        
        if let Some(max_memory) = threshold.max_memory_mb {
            if metrics.peak_memory_mb > max_memory {
                failures.push(format!("Peak memory {:.2} MB exceeds maximum {:.2} MB",
                    metrics.peak_memory_mb, max_memory));
                passed = false;
            }
        }
        
        if let Some(max_error_rate) = threshold.max_error_rate {
            if metrics.error_rate > max_error_rate {
                failures.push(format!("Error rate {:.4} exceeds maximum {:.4}",
                    metrics.error_rate, max_error_rate));
                passed = false;
            }
        }
        
        Ok(BenchmarkResult {
            config,
            metrics,
            passed,
            failures,
            timestamp: chrono::Utc::now(),
            metadata: std::collections::HashMap::new(),
        })
    }
    
    /// Execute a single benchmark iteration
    fn execute_benchmark_iteration(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        match config.benchmark_type {
            BenchmarkType::TTFSEncoding => self.run_ttfs_encoding(config),
            BenchmarkType::ColumnAllocation => self.run_column_allocation(config),
            BenchmarkType::LateralInhibition => self.run_lateral_inhibition(config),
            BenchmarkType::MemoryConsolidation => self.run_memory_consolidation(config),
            BenchmarkType::SIMDOperations => self.run_simd_operations(config),
            BenchmarkType::FullPipeline => self.run_full_pipeline(config),
            BenchmarkType::StressTest => self.run_stress_test(config),
            BenchmarkType::MemoryBenchmark => self.run_memory_benchmark(config),
            BenchmarkType::ConcurrencyTest => self.run_concurrency_test(config),
            BenchmarkType::SimilarityComputation => self.run_similarity_computation(config),
        }
    }
    
    // Individual benchmark implementations (simplified for mock testing)
    
    fn run_ttfs_encoding(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        // Simulate TTFS encoding work
        let work_duration = std::time::Duration::from_micros(500);
        thread::sleep(work_duration);
        Ok(())
    }
    
    fn run_column_allocation(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        let work_duration = std::time::Duration::from_micros(1000);
        thread::sleep(work_duration);
        Ok(())
    }
    
    fn run_lateral_inhibition(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        let work_duration = std::time::Duration::from_micros(750);
        thread::sleep(work_duration);
        Ok(())
    }
    
    fn run_memory_consolidation(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        let work_duration = std::time::Duration::from_millis(50);
        thread::sleep(work_duration);
        Ok(())
    }
    
    fn run_simd_operations(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        let work_duration = std::time::Duration::from_micros(100);
        thread::sleep(work_duration);
        Ok(())
    }
    
    fn run_full_pipeline(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        let work_duration = std::time::Duration::from_millis(5);
        thread::sleep(work_duration);
        Ok(())
    }
    
    fn run_stress_test(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        if let Some(duration) = config.duration {
            thread::sleep(duration);
        } else {
            thread::sleep(std::time::Duration::from_millis(100));
        }
        Ok(())
    }
    
    fn run_memory_benchmark(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        // Allocate and deallocate memory
        let _data: Vec<u8> = vec![0; config.data_size * 1024];
        thread::sleep(std::time::Duration::from_micros(200));
        Ok(())
    }
    
    fn run_concurrency_test(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        let handles: Vec<_> = (0..config.concurrency)
            .map(|_| {
                thread::spawn(|| {
                    thread::sleep(std::time::Duration::from_micros(1000));
                })
            })
            .collect();
        
        for handle in handles {
            handle.join().map_err(|_| BenchmarkError::ConcurrencyError)?;
        }
        
        Ok(())
    }
    
    fn run_similarity_computation(&self, config: &BenchmarkConfig) -> Result<(), BenchmarkError> {
        // Simulate similarity calculations
        let work_duration = std::time::Duration::from_micros(300);
        thread::sleep(work_duration);
        Ok(())
    }
}

/// Benchmark execution errors
#[derive(Debug, thiserror::Error)]
pub enum BenchmarkError {
    #[error("Benchmark execution failed: {0}")]
    ExecutionFailed(String),
    
    #[error("Concurrency error during benchmark")]
    ConcurrencyError,
    
    #[error("Invalid configuration: {0}")]
    InvalidConfig(String),
    
    #[error("Timeout during benchmark execution")]
    Timeout,
}
```

3. Update crates/neuromorphic-benchmarks/Cargo.toml to add CLI dependencies:

```toml
# Add to dependencies section:
clap = { version = "4.4", features = ["derive"] }
env_logger = "0.10"
chrono = { workspace = true, features = ["serde"] }
thiserror = "1.0"

# Add binary definition:
[[bin]]
name = "benchmark"
path = "src/bin/benchmark.rs"
```

4. Test the CLI tool:
   cd crates/neuromorphic-benchmarks
   cargo build --release --bin benchmark

Core benchmark CLI tool and execution engine are now implemented with comprehensive functionality.
```

## Success Criteria
- [ ] Main benchmark CLI tool operational
- [ ] BenchmarkRunner core functionality working
- [ ] Configuration management system
- [ ] Output formatting and threshold validation