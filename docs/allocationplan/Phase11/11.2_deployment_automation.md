# 11.2 Deployment Automation - Micro Tasks

## Overview
Implement automated deployment pipelines for the neuromorphic knowledge graph system with container orchestration, CI/CD integration, and zero-downtime deployments.

## Micro Tasks

### Task 11.2.1: Create Multi-Stage Dockerfile
**Objective**: Build optimized container images with minimal attack surface.

**Requirements**:
- Multi-stage build for size optimization
- Non-root user execution
- Health check integration
- Security scanning hooks

**Implementation**:
```dockerfile
# Create Dockerfile
# Build stage
FROM rust:1.75-slim as builder
WORKDIR /app
COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs
RUN cargo build --release && rm -rf src

COPY . .
RUN touch src/main.rs && cargo build --release

# Runtime stage
FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

RUN useradd -m -u 1001 -s /bin/bash neuromorphic
WORKDIR /app

COPY --from=builder --chown=neuromorphic:neuromorphic \
    /app/target/release/neuromorphic-kg /app/

USER neuromorphic
EXPOSE 8080 9090
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ["/app/neuromorphic-kg", "health"]

CMD ["/app/neuromorphic-kg", "serve"]
```

**Validation**:
- Image size < 100MB
- Security scan passes
- Health checks work
- Non-root execution verified

---

### Task 11.2.2a: Create Kubernetes Deployment Manifest
**Objective**: Create the main deployment configuration with rolling update strategy.

**Requirements**:
- Single deployment configuration
- Rolling update parameters
- Pod template specification
- Resource limits and health checks

**Implementation**:
```yaml
# Create k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: neuromorphic-kg
  labels:
    app: neuromorphic-kg
spec:
  replicas: 3
  selector:
    matchLabels:
      app: neuromorphic-kg
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: neuromorphic-kg
    spec:
      containers:
      - name: neuromorphic-kg
        image: neuromorphic-kg:latest
        ports:
        - containerPort: 8080
          name: http
        - containerPort: 9090
          name: metrics
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "2000m"
        env:
        - name: RUST_LOG
          value: "info"
        volumeMounts:
        - name: config
          mountPath: /app/config
          readOnly: true
      volumes:
      - name: config
        configMap:
          name: neuromorphic-kg-config
```

**Validation**:
- Deployment manifest validates with kubectl
- Pod template contains all required fields
- Rolling update strategy configured correctly
- Resource limits defined

---

### Task 11.2.2b: Create Kubernetes Service Manifests
**Objective**: Create service definitions for traffic routing and load balancing.

**Requirements**:
- Main application service
- Metrics service for monitoring
- Service type and port configuration
- Selector matching deployment labels

**Implementation**:
```yaml
# Create k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: neuromorphic-kg
  labels:
    app: neuromorphic-kg
spec:
  type: ClusterIP
  selector:
    app: neuromorphic-kg
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: metrics
    port: 9090
    targetPort: 9090
    protocol: TCP

---
# Create k8s/service-metrics.yaml
apiVersion: v1
kind: Service
metadata:
  name: neuromorphic-kg-metrics
  labels:
    app: neuromorphic-kg
    component: metrics
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9090"
    prometheus.io/path: "/metrics"
spec:
  type: ClusterIP
  selector:
    app: neuromorphic-kg
  ports:
  - name: metrics
    port: 9090
    targetPort: 9090
    protocol: TCP
```

**Validation**:
- Service endpoints resolve correctly
- Load balancing functions properly
- Metrics service discoverable by Prometheus
- Port mappings correct

---

### Task 11.2.2c: Create ConfigMap and Secret Manifests
**Objective**: Create configuration management resources for application settings.

**Requirements**:
- ConfigMap for non-sensitive application configuration
- Secret for sensitive data (API keys, database credentials)
- Proper data structure and encoding
- Volume mount compatibility

**Implementation**:
```yaml
# Create k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: neuromorphic-kg-config
  labels:
    app: neuromorphic-kg
data:
  app.yaml: |
    server:
      host: 0.0.0.0
      port: 8080
      workers: 4
    
    metrics:
      enabled: true
      port: 9090
      path: /metrics
    
    logging:
      level: info
      format: json
    
    allocation:
      max_concurrent: 1000
      timeout_ms: 5000
      cache_size: 10000
    
    neural_networks:
      model_path: /app/models
      batch_size: 32
      inference_timeout_ms: 1000

---
# Create k8s/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: neuromorphic-kg-secrets
  labels:
    app: neuromorphic-kg
type: Opaque
data:
  database-url: cG9zdGdyZXM6Ly91c2VyOnBhc3NAaG9zdDo1NDMyL2RiCg==  # base64 encoded
  api-key: YWJjZGVmZ2hpams=  # base64 encoded
  jwt-secret: c3VwZXJfc2VjcmV0X2tleQ==  # base64 encoded
```

**Validation**:
- ConfigMap data structure valid
- Secret data properly base64 encoded
- Volume mounts reference correct keys
- Configuration loads in application

---

### Task 11.2.2d: Create RBAC and ServiceAccount Manifests
**Objective**: Create role-based access control and service account for security.

**Requirements**:
- ServiceAccount for pod identity
- Role with minimal required permissions
- RoleBinding to associate role with service account
- Security best practices applied

**Implementation**:
```yaml
# Create k8s/rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: neuromorphic-kg
  labels:
    app: neuromorphic-kg

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: neuromorphic-kg
  labels:
    app: neuromorphic-kg
rules:
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: neuromorphic-kg
  labels:
    app: neuromorphic-kg
subjects:
- kind: ServiceAccount
  name: neuromorphic-kg
  namespace: default
roleRef:
  kind: Role
  name: neuromorphic-kg
  apiGroup: rbac.authorization.k8s.io
```

**Validation**:
- ServiceAccount created successfully
- Role permissions minimal and functional
- RoleBinding correctly associates components
- Pod can access required resources

---

### Task 11.2.3: Create Helm Chart
**Objective**: Package application for flexible deployment across environments.

**Requirements**:
- Parameterized configurations
- Environment-specific values
- Dependency management
- Upgrade/rollback support

**Implementation**:
```yaml
# Create helm/neuromorphic-kg/Chart.yaml
apiVersion: v2
name: neuromorphic-kg
description: Neuromorphic Knowledge Graph System
type: application
version: 0.1.0
appVersion: "1.0.0"

# Create helm/neuromorphic-kg/values.yaml
replicaCount: 3

image:
  repository: neuromorphic-kg
  pullPolicy: IfNotPresent
  tag: ""

service:
  type: ClusterIP
  port: 8080
  metricsPort: 9090

ingress:
  enabled: false
  className: "nginx"
  annotations: {}
  hosts:
    - host: neuromorphic.local
      paths:
        - path: /
          pathType: ImplementationSpecific

resources:
  limits:
    cpu: 2000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
```

**Validation**:
- Helm lint passes
- Dry-run successful
- Values override correctly
- Upgrade path tested

---

### Task 11.2.4: Implement CI/CD Pipeline
**Objective**: Automated build, test, and deployment pipeline.

**Requirements**:
- GitHub Actions workflow
- Automated testing
- Container registry push
- Environment promotions

**Implementation**:
```yaml
# Create .github/workflows/deploy.yml
name: Build and Deploy

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: stable
        override: true
    
    - name: Run tests
      run: |
        cargo test --all-features
        cargo clippy -- -D warnings
    
    - name: Security audit
      run: cargo audit

  build:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to Kubernetes
      uses: azure/k8s-deploy@v4
      with:
        manifests: |
          k8s/deployment.yaml
          k8s/service.yaml
        images: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
```

**Validation**:
- Pipeline runs successfully
- Tests block bad builds
- Images pushed to registry
- Deployment triggers work

---

### Task 11.2.5: Create GitOps Configuration
**Objective**: Implement GitOps workflow with ArgoCD/Flux.

**Requirements**:
- Declarative deployment configs
- Automated sync policies
- Multi-environment support
- Rollback capabilities

**Implementation**:
```yaml
# Create gitops/applications/neuromorphic-kg.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: neuromorphic-kg
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/org/neuromorphic-kg
    targetRevision: HEAD
    path: helm/neuromorphic-kg
    helm:
      valueFiles:
      - values.yaml
      - values-prod.yaml
  destination:
    server: https://kubernetes.default.svc
    namespace: neuromorphic-system
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
      allowEmpty: false
    syncOptions:
    - CreateNamespace=true
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
```

**Validation**:
- ArgoCD syncs successfully
- Auto-sync works on commits
- Rollback functions correctly
- Multi-env deployments work

---

### Task 11.2.6: Implement Blue-Green Deployment
**Objective**: Zero-downtime deployments with instant rollback capability.

**Requirements**:
- Traffic switching mechanism
- Health validation gates
- Automated rollback triggers
- Session affinity handling

**Implementation**:
```yaml
# Create k8s/blue-green/service-selector.yaml
apiVersion: v1
kind: Service
metadata:
  name: neuromorphic-kg-active
spec:
  selector:
    app: neuromorphic-kg
    version: blue  # Switch between blue/green
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080

# Create scripts/blue-green-deploy.sh
#!/bin/bash
set -e

CURRENT_VERSION=$(kubectl get service neuromorphic-kg-active -o jsonpath='{.spec.selector.version}')
NEW_VERSION="green"
if [ "$CURRENT_VERSION" == "green" ]; then
    NEW_VERSION="blue"
fi

echo "Deploying to $NEW_VERSION environment..."
kubectl set image deployment/neuromorphic-kg-$NEW_VERSION \
    neuromorphic-kg=$IMAGE:$TAG

echo "Waiting for rollout..."
kubectl rollout status deployment/neuromorphic-kg-$NEW_VERSION

echo "Running smoke tests..."
./scripts/smoke-test.sh $NEW_VERSION

echo "Switching traffic to $NEW_VERSION..."
kubectl patch service neuromorphic-kg-active \
    -p '{"spec":{"selector":{"version":"'$NEW_VERSION'"}}}'

echo "Deployment complete!"
```

**Validation**:
- Zero downtime during switch
- Rollback < 10 seconds
- Health checks prevent bad switches
- Load balancer updates correctly

---

### Task 11.2.7: Add Database Migration Automation
**Objective**: Safe, automated database schema migrations in production.

**Requirements**:
- Pre-deployment migrations
- Rollback support
- Migration validation
- Zero-downtime migrations

**Implementation**:
```rust
// Create src/migrations/runner.rs
use sqlx::migrate::Migrator;
use sqlx::postgres::PgPool;

pub struct MigrationRunner {
    pool: PgPool,
    migrator: Migrator,
}

impl MigrationRunner {
    pub async fn run_pending(&self) -> Result<()> {
        // Acquire migration lock
        let mut tx = self.pool.begin().await?;
        sqlx::query("SELECT pg_advisory_xact_lock(1337)")
            .execute(&mut tx)
            .await?;
        
        // Run migrations
        self.migrator.run(&self.pool).await?;
        
        // Validate migrations
        let applied = self.migrator.iter()
            .filter(|m| m.migration_type.is_up())
            .count();
        
        info!("Applied {} migrations", applied);
        tx.commit().await?;
        Ok(())
    }
}

// Create k8s/migration-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: db-migration
spec:
  template:
    spec:
      restartPolicy: Never
      initContainers:
      - name: wait-for-db
        image: busybox
        command: ['sh', '-c', 'until nc -z postgres 5432; do sleep 1; done']
      containers:
      - name: migrate
        image: neuromorphic-kg:latest
        command: ["./neuromorphic-kg", "migrate", "up"]
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: url
```

**Validation**:
- Migrations apply cleanly
- Rollback works correctly
- Lock prevents races
- No data loss

---

### Task 11.2.8: Create Canary Deployment Strategy
**Objective**: Gradual rollout with automatic rollback on errors.

**Requirements**:
- Percentage-based traffic splitting
- Error rate monitoring
- Automatic rollback triggers
- A/B testing support

**Implementation**:
```yaml
# Create k8s/canary/rollout.yaml
apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: neuromorphic-kg
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: neuromorphic-kg
  service:
    port: 80
    targetPort: 8080
    gateways:
    - public-gateway.istio-system.svc.cluster.local
    hosts:
    - neuromorphic.example.com
  analysis:
    interval: 1m
    threshold: 10
    maxWeight: 50
    stepWeight: 10
    metrics:
    - name: request-success-rate
      thresholdRange:
        min: 99
      interval: 1m
    - name: request-duration
      thresholdRange:
        max: 500
      interval: 30s
    webhooks:
    - name: load-test
      url: http://flagger-loadtester.test/
      timeout: 5s
      metadata:
        cmd: "hey -z 1m -q 10 -c 2 http://neuromorphic.example.com/"
```

**Validation**:
- Canary deployments work
- Traffic shifts gradually
- Rollback on high errors
- Metrics tracked correctly

---

### Task 11.2.9: Implement Secret Management
**Objective**: Secure secret storage and rotation for production.

**Requirements**:
- External secret operator integration
- Automatic rotation support
- Audit logging
- Encryption at rest

**Implementation**:
```yaml
# Create k8s/external-secrets/secret-store.yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-backend
spec:
  provider:
    vault:
      server: "https://vault.example.com:8200"
      path: "secret"
      version: "v2"
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "neuromorphic-kg"
          serviceAccountRef:
            name: "neuromorphic-kg"

# Create k8s/external-secrets/external-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: neuromorphic-secrets
spec:
  refreshInterval: 15m
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: neuromorphic-secrets
    creationPolicy: Owner
  data:
  - secretKey: database-url
    remoteRef:
      key: neuromorphic/database
      property: url
  - secretKey: api-key
    remoteRef:
      key: neuromorphic/api
      property: key
```

**Validation**:
- Secrets sync from vault
- Rotation works automatically
- No secrets in git
- Audit logs present

---

### Task 11.2.10: Create Deployment Documentation
**Objective**: Comprehensive deployment runbooks and automation docs.

**Requirements**:
- Step-by-step deployment guide
- Troubleshooting procedures
- Rollback instructions
- Monitoring setup guide

**Implementation**:
```markdown
# Create docs/deployment/README.md
# Neuromorphic KG Deployment Guide

## Prerequisites
- Kubernetes 1.27+
- Helm 3.12+
- kubectl configured
- Container registry access

## Deployment Steps

### 1. Initial Setup
\```bash
# Create namespace
kubectl create namespace neuromorphic-system

# Install secrets
kubectl apply -f k8s/secrets/

# Install ConfigMaps
kubectl apply -f k8s/configmaps/
\```

### 2. Database Setup
\```bash
# Run migrations
kubectl apply -f k8s/migration-job.yaml
kubectl wait --for=condition=complete job/db-migration
\```

### 3. Deploy Application
\```bash
# Using Helm
helm install neuromorphic-kg ./helm/neuromorphic-kg \
  --namespace neuromorphic-system \
  --values values-prod.yaml

# Or using kubectl
kubectl apply -f k8s/
\```

### 4. Verify Deployment
\```bash
# Check pod status
kubectl get pods -n neuromorphic-system

# Check service endpoints
kubectl get endpoints -n neuromorphic-system

# Run smoke tests
./scripts/smoke-test.sh production
\```

## Rollback Procedures
\```bash
# Helm rollback
helm rollback neuromorphic-kg 1 -n neuromorphic-system

# Blue-green instant rollback
./scripts/blue-green-rollback.sh
\```
```

**Validation**:
- Docs are accurate
- Commands work as written
- Covers all scenarios
- Easy to follow

## Dependencies
- Docker 24.0+
- Kubernetes 1.27+
- Helm 3.12+
- ArgoCD 2.8+
- Flagger 1.32+

## Success Metrics
- ✅ < 5 minute deployments
- ✅ Zero-downtime updates
- ✅ < 10 second rollbacks
- ✅ 100% deployment success rate
- ✅ Automated security scanning