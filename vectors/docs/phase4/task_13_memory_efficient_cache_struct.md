# Task 13: Create MemoryEfficientCache Struct

## Context
You are implementing Phase 4 of a vector indexing system. This task begins the memory management and caching component, which provides intelligent query result caching with memory limits and eviction policies.

## Current State
- Parallel indexing is implemented in `src/parallel.rs`
- Search engines exist in `src/search.rs`
- Now implementing caching layer for performance optimization

## Task Objective
Create the basic `MemoryEfficientCache` struct in a new file `src/cache.rs` with configuration options and basic structure for caching search results.

## Implementation Requirements

### 1. Create `src/cache.rs` file
```rust
use std::collections::HashMap;\nuse std::sync::{Arc, RwLock};\nuse crate::search::SearchResult;\n\npub struct MemoryEfficientCache {\n    query_cache: Arc<RwLock<HashMap<String, CacheEntry>>>,\n    max_entries: usize,\n    max_memory_mb: usize,\n    current_memory_usage: Arc<RwLock<usize>>,\n}\n\n#[derive(Debug, Clone)]\nstruct CacheEntry {\n    results: Vec<SearchResult>,\n    timestamp: std::time::Instant,\n    access_count: usize,\n    estimated_size: usize,\n}\n\nimpl CacheEntry {\n    fn new(results: Vec<SearchResult>) -> Self {\n        let estimated_size = Self::estimate_size(&results);\n        Self {\n            results,\n            timestamp: std::time::Instant::now(),\n            access_count: 1,\n            estimated_size,\n        }\n    }\n    \n    fn estimate_size(results: &[SearchResult]) -> usize {\n        results.iter()\n            .map(|r| r.file_path.len() + r.content.len() + std::mem::size_of::<SearchResult>())\n            .sum()\n    }\n    \n    fn touch(&mut self) {\n        self.access_count += 1;\n        self.timestamp = std::time::Instant::now();\n    }\n}\n\nimpl MemoryEfficientCache {\n    pub fn new(max_entries: usize, max_memory_mb: usize) -> Self {\n        Self {\n            query_cache: Arc::new(RwLock::new(HashMap::new())),\n            max_entries,\n            max_memory_mb,\n            current_memory_usage: Arc::new(RwLock::new(0)),\n        }\n    }\n    \n    pub fn with_defaults() -> Self {\n        Self::new(1000, 100) // 1000 entries, 100MB limit\n    }\n    \n    pub fn max_entries(&self) -> usize {\n        self.max_entries\n    }\n    \n    pub fn max_memory_mb(&self) -> usize {\n        self.max_memory_mb\n    }\n    \n    pub fn current_entries(&self) -> usize {\n        self.query_cache.read().unwrap().len()\n    }\n    \n    pub fn current_memory_usage(&self) -> usize {\n        *self.current_memory_usage.read().unwrap()\n    }\n    \n    pub fn current_memory_usage_mb(&self) -> f64 {\n        self.current_memory_usage() as f64 / (1024.0 * 1024.0)\n    }\n}\n```\n\n### 2. Update `src/lib.rs`\nAdd this line to expose the new module:\n```rust\npub mod cache;\n```\n\n### 3. Add basic configuration tests\nAdd these tests at the bottom of `src/cache.rs`:\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_cache_creation() {\n        let cache = MemoryEfficientCache::new(500, 50);\n        \n        assert_eq!(cache.max_entries(), 500);\n        assert_eq!(cache.max_memory_mb(), 50);\n        assert_eq!(cache.current_entries(), 0);\n        assert_eq!(cache.current_memory_usage(), 0);\n    }\n    \n    #[test]\n    fn test_cache_defaults() {\n        let cache = MemoryEfficientCache::with_defaults();\n        \n        assert_eq!(cache.max_entries(), 1000);\n        assert_eq!(cache.max_memory_mb(), 100);\n        assert_eq!(cache.current_entries(), 0);\n    }\n    \n    #[test]\n    fn test_cache_entry_size_estimation() {\n        let results = vec![\n            SearchResult {\n                file_path: \"test.rs\".to_string(),\n                content: \"pub fn test() {}\".to_string(),\n                chunk_index: 0,\n                score: 1.0,\n            },\n            SearchResult {\n                file_path: \"main.rs\".to_string(),\n                content: \"fn main() { println!(\\\"Hello\\\"); }\".to_string(),\n                chunk_index: 0,\n                score: 0.8,\n            },\n        ];\n        \n        let entry = CacheEntry::new(results.clone());\n        \n        assert_eq!(entry.results.len(), 2);\n        assert_eq!(entry.access_count, 1);\n        assert!(entry.estimated_size > 0);\n        \n        // Size should include file paths, content, and struct overhead\n        let expected_min_size = \"test.rs\".len() + \"pub fn test() {}\".len() +\n                              \"main.rs\".len() + \"fn main() { println!(\\\"Hello\\\"); }\".len();\n        assert!(entry.estimated_size >= expected_min_size);\n    }\n    \n    #[test]\n    fn test_cache_entry_touch() {\n        let results = vec![\n            SearchResult {\n                file_path: \"test.rs\".to_string(),\n                content: \"content\".to_string(),\n                chunk_index: 0,\n                score: 1.0,\n            }\n        ];\n        \n        let mut entry = CacheEntry::new(results);\n        let initial_timestamp = entry.timestamp;\n        let initial_count = entry.access_count;\n        \n        std::thread::sleep(std::time::Duration::from_millis(10));\n        entry.touch();\n        \n        assert!(entry.timestamp > initial_timestamp);\n        assert_eq!(entry.access_count, initial_count + 1);\n    }\n}\n```\n\n### 4. Add cache statistics struct\nAdd this before the `MemoryEfficientCache` implementation:\n```rust\n#[derive(Debug, Clone)]\npub struct CacheStats {\n    pub entries: usize,\n    pub memory_usage_bytes: usize,\n    pub memory_usage_mb: f64,\n    pub hit_rate: f64,\n    pub total_hits: usize,\n    pub total_misses: usize,\n}\n\nimpl CacheStats {\n    pub fn memory_utilization(&self, max_memory_mb: usize) -> f64 {\n        self.memory_usage_mb / max_memory_mb as f64\n    }\n}\n```\n\n### 5. Add get_stats() method to cache\nAdd this method to the `MemoryEfficientCache` implementation:\n```rust\npub fn get_stats(&self) -> CacheStats {\n    let cache_guard = self.query_cache.read().unwrap();\n    let memory_usage = *self.current_memory_usage.read().unwrap();\n    \n    // For now, we'll add hit/miss tracking in subsequent tasks\n    CacheStats {\n        entries: cache_guard.len(),\n        memory_usage_bytes: memory_usage,\n        memory_usage_mb: memory_usage as f64 / (1024.0 * 1024.0),\n        hit_rate: 0.0, // Will be implemented later\n        total_hits: 0,  // Will be implemented later\n        total_misses: 0, // Will be implemented later\n    }\n}\n```\n\n## Success Criteria\n- [ ] File `src/cache.rs` created successfully\n- [ ] `MemoryEfficientCache` struct compiles without errors\n- [ ] `CacheEntry` struct properly estimates memory usage\n- [ ] Configuration methods work correctly\n- [ ] Statistics structure is in place\n- [ ] All tests pass\n- [ ] No compilation errors or warnings\n\n## Time Limit\n10 minutes\n\n## Notes\n- Focus on creating the basic structure and configuration\n- Memory estimation is approximate but should be reasonable\n- Thread safety is provided by RwLock\n- Actual cache operations (get/put) will be implemented in subsequent tasks\n- Statistics tracking will be enhanced in later tasks