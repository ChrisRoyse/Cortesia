# Task 37: Create PerformanceMonitor Struct

## Context
You are implementing Phase 4 of a vector indexing system. This task begins the performance monitoring component, which tracks query times, indexing performance, and provides statistical analysis for optimization.

## Current State  
- Parallel indexing is implemented in `src/parallel.rs`
- Memory efficient caching is implemented in `src/cache.rs`
- Windows optimizations are implemented in `src/windows.rs`
- Now implementing performance monitoring

## Task Objective
Create the `PerformanceMonitor` struct in a new file `src/monitor.rs` with time series data collection and statistical analysis capabilities.

## Implementation Requirements

### 1. Create `src/monitor.rs` file
```rust
use std::time::{Duration, Instant};\nuse std::collections::VecDeque;\n\npub struct PerformanceMonitor {\n    query_times: VecDeque<Duration>,\n    index_times: VecDeque<Duration>,\n    max_samples: usize,\n    start_time: Instant,\n    total_queries: usize,\n    total_indexes: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct PerformanceStats {\n    pub avg_query_time: Duration,\n    pub p95_query_time: Duration,\n    pub p99_query_time: Duration,\n    pub min_query_time: Duration,\n    pub max_query_time: Duration,\n    pub avg_index_time: Duration,\n    pub p95_index_time: Duration,\n    pub p99_index_time: Duration,\n    pub min_index_time: Duration,\n    pub max_index_time: Duration,\n    pub total_queries: usize,\n    pub total_indexes: usize,\n    pub uptime: Duration,\n    pub queries_per_second: f64,\n    pub indexes_per_second: f64,\n}\n\nimpl PerformanceMonitor {\n    pub fn new() -> Self {\n        Self::with_capacity(10000) // Default to 10,000 samples\n    }\n    \n    pub fn with_capacity(max_samples: usize) -> Self {\n        Self {\n            query_times: VecDeque::with_capacity(max_samples),\n            index_times: VecDeque::with_capacity(max_samples),\n            max_samples,\n            start_time: Instant::now(),\n            total_queries: 0,\n            total_indexes: 0,\n        }\n    }\n    \n    pub fn record_query_time(&mut self, duration: Duration) {\n        self.query_times.push_back(duration);\n        self.total_queries += 1;\n        \n        // Keep only the most recent max_samples\n        if self.query_times.len() > self.max_samples {\n            self.query_times.pop_front();\n        }\n    }\n    \n    pub fn record_index_time(&mut self, duration: Duration) {\n        self.index_times.push_back(duration);\n        self.total_indexes += 1;\n        \n        // Keep only the most recent max_samples\n        if self.index_times.len() > self.max_samples {\n            self.index_times.pop_front();\n        }\n    }\n    \n    pub fn get_stats(&self) -> PerformanceStats {\n        let uptime = self.start_time.elapsed();\n        let uptime_seconds = uptime.as_secs_f64();\n        \n        PerformanceStats {\n            avg_query_time: self.average(&self.query_times),\n            p95_query_time: self.percentile(&self.query_times, 95),\n            p99_query_time: self.percentile(&self.query_times, 99),\n            min_query_time: self.minimum(&self.query_times),\n            max_query_time: self.maximum(&self.query_times),\n            avg_index_time: self.average(&self.index_times),\n            p95_index_time: self.percentile(&self.index_times, 95),\n            p99_index_time: self.percentile(&self.index_times, 99),\n            min_index_time: self.minimum(&self.index_times),\n            max_index_time: self.maximum(&self.index_times),\n            total_queries: self.total_queries,\n            total_indexes: self.total_indexes,\n            uptime,\n            queries_per_second: if uptime_seconds > 0.0 { \n                self.total_queries as f64 / uptime_seconds \n            } else { 0.0 },\n            indexes_per_second: if uptime_seconds > 0.0 { \n                self.total_indexes as f64 / uptime_seconds \n            } else { 0.0 },\n        }\n    }\n    \n    fn average(&self, durations: &VecDeque<Duration>) -> Duration {\n        if durations.is_empty() {\n            return Duration::from_millis(0);\n        }\n        \n        let total: Duration = durations.iter().sum();\n        total / durations.len() as u32\n    }\n    \n    fn percentile(&self, durations: &VecDeque<Duration>, percentile: u8) -> Duration {\n        if durations.is_empty() {\n            return Duration::from_millis(0);\n        }\n        \n        let mut sorted: Vec<_> = durations.iter().cloned().collect();\n        sorted.sort();\n        \n        let index = (percentile as f64 / 100.0 * sorted.len() as f64) as usize;\n        sorted.get(index.min(sorted.len() - 1)).copied().unwrap_or_default()\n    }\n    \n    fn minimum(&self, durations: &VecDeque<Duration>) -> Duration {\n        durations.iter().min().copied().unwrap_or_default()\n    }\n    \n    fn maximum(&self, durations: &VecDeque<Duration>) -> Duration {\n        durations.iter().max().copied().unwrap_or_default()\n    }\n    \n    pub fn reset(&mut self) {\n        self.query_times.clear();\n        self.index_times.clear();\n        self.start_time = Instant::now();\n        self.total_queries = 0;\n        self.total_indexes = 0;\n    }\n    \n    pub fn current_sample_count(&self) -> (usize, usize) {\n        (self.query_times.len(), self.index_times.len())\n    }\n}\n\nimpl PerformanceStats {\n    pub fn query_performance_summary(&self) -> String {\n        format!(\n            \"Query Performance: avg={:.2}ms, p95={:.2}ms, p99={:.2}ms, min={:.2}ms, max={:.2}ms ({} total, {:.1}/s)\",\n            self.avg_query_time.as_secs_f64() * 1000.0,\n            self.p95_query_time.as_secs_f64() * 1000.0,\n            self.p99_query_time.as_secs_f64() * 1000.0,\n            self.min_query_time.as_secs_f64() * 1000.0,\n            self.max_query_time.as_secs_f64() * 1000.0,\n            self.total_queries,\n            self.queries_per_second\n        )\n    }\n    \n    pub fn index_performance_summary(&self) -> String {\n        format!(\n            \"Index Performance: avg={:.2}ms, p95={:.2}ms, p99={:.2}ms, min={:.2}ms, max={:.2}ms ({} total, {:.1}/s)\",\n            self.avg_index_time.as_secs_f64() * 1000.0,\n            self.p95_index_time.as_secs_f64() * 1000.0,\n            self.p99_index_time.as_secs_f64() * 1000.0,\n            self.min_index_time.as_secs_f64() * 1000.0,\n            self.max_index_time.as_secs_f64() * 1000.0,\n            self.total_indexes,\n            self.indexes_per_second\n        )\n    }\n    \n    pub fn full_summary(&self) -> String {\n        format!(\n            \"Performance Summary (uptime: {:.1}s):\\n  {}\\n  {}\",\n            self.uptime.as_secs_f64(),\n            self.query_performance_summary(),\n            self.index_performance_summary()\n        )\n    }\n}\n```\n\n### 2. Update `src/lib.rs`\nAdd this line to expose the new module:\n```rust\npub mod monitor;\n```\n\n### 3. Add comprehensive tests\nAdd these tests at the bottom of `src/monitor.rs`:\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::thread;\n    \n    #[test]\n    fn test_performance_monitor_creation() {\n        let monitor = PerformanceMonitor::new();\n        let (query_samples, index_samples) = monitor.current_sample_count();\n        \n        assert_eq!(query_samples, 0);\n        assert_eq!(index_samples, 0);\n        \n        let stats = monitor.get_stats();\n        assert_eq!(stats.total_queries, 0);\n        assert_eq!(stats.total_indexes, 0);\n    }\n    \n    #[test]\n    fn test_query_time_recording() {\n        let mut monitor = PerformanceMonitor::new();\n        \n        // Record some query times\n        monitor.record_query_time(Duration::from_millis(10));\n        monitor.record_query_time(Duration::from_millis(20));\n        monitor.record_query_time(Duration::from_millis(30));\n        \n        let stats = monitor.get_stats();\n        assert_eq!(stats.total_queries, 3);\n        assert_eq!(stats.avg_query_time, Duration::from_millis(20));\n        assert_eq!(stats.min_query_time, Duration::from_millis(10));\n        assert_eq!(stats.max_query_time, Duration::from_millis(30));\n    }\n    \n    #[test]\n    fn test_index_time_recording() {\n        let mut monitor = PerformanceMonitor::new();\n        \n        // Record some index times\n        monitor.record_index_time(Duration::from_millis(100));\n        monitor.record_index_time(Duration::from_millis(200));\n        monitor.record_index_time(Duration::from_millis(150));\n        \n        let stats = monitor.get_stats();\n        assert_eq!(stats.total_indexes, 3);\n        assert_eq!(stats.avg_index_time, Duration::from_millis(150));\n        assert_eq!(stats.min_index_time, Duration::from_millis(100));\n        assert_eq!(stats.max_index_time, Duration::from_millis(200));\n    }\n    \n    #[test]\n    fn test_percentile_calculations() {\n        let mut monitor = PerformanceMonitor::new();\n        \n        // Record times: 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 ms\n        for i in 1..=10 {\n            monitor.record_query_time(Duration::from_millis(i * 10));\n        }\n        \n        let stats = monitor.get_stats();\n        \n        // P95 should be around 95ms (95th percentile of 10 values)\n        assert!(stats.p95_query_time >= Duration::from_millis(90));\n        assert!(stats.p95_query_time <= Duration::from_millis(100));\n        \n        // P99 should be around 99ms (99th percentile of 10 values)\n        assert!(stats.p99_query_time >= Duration::from_millis(90));\n        assert!(stats.p99_query_time <= Duration::from_millis(100));\n    }\n    \n    #[test]\n    fn test_sample_capacity_limit() {\n        let mut monitor = PerformanceMonitor::with_capacity(3);\n        \n        // Add more samples than capacity\n        for i in 1..=5 {\n            monitor.record_query_time(Duration::from_millis(i * 10));\n        }\n        \n        let (query_samples, _) = monitor.current_sample_count();\n        assert_eq!(query_samples, 3); // Should be limited to capacity\n        \n        let stats = monitor.get_stats();\n        assert_eq!(stats.total_queries, 5); // Total count should still be accurate\n        \n        // Should only have the last 3 samples: 30, 40, 50ms\n        assert_eq!(stats.min_query_time, Duration::from_millis(30));\n        assert_eq!(stats.max_query_time, Duration::from_millis(50));\n    }\n    \n    #[test]\n    fn test_rates_calculation() {\n        let mut monitor = PerformanceMonitor::new();\n        \n        // Record some operations\n        monitor.record_query_time(Duration::from_millis(10));\n        monitor.record_query_time(Duration::from_millis(20));\n        monitor.record_index_time(Duration::from_millis(100));\n        \n        // Wait a bit to get meaningful rates\n        thread::sleep(Duration::from_millis(100));\n        \n        let stats = monitor.get_stats();\n        \n        assert!(stats.queries_per_second > 0.0);\n        assert!(stats.indexes_per_second > 0.0);\n        assert!(stats.uptime >= Duration::from_millis(100));\n    }\n    \n    #[test]\n    fn test_reset_functionality() {\n        let mut monitor = PerformanceMonitor::new();\n        \n        // Record some data\n        monitor.record_query_time(Duration::from_millis(10));\n        monitor.record_index_time(Duration::from_millis(100));\n        \n        let stats_before = monitor.get_stats();\n        assert_eq!(stats_before.total_queries, 1);\n        assert_eq!(stats_before.total_indexes, 1);\n        \n        // Reset the monitor\n        monitor.reset();\n        \n        let stats_after = monitor.get_stats();\n        assert_eq!(stats_after.total_queries, 0);\n        assert_eq!(stats_after.total_indexes, 0);\n        \n        let (query_samples, index_samples) = monitor.current_sample_count();\n        assert_eq!(query_samples, 0);\n        assert_eq!(index_samples, 0);\n    }\n    \n    #[test]\n    fn test_summary_formatting() {\n        let mut monitor = PerformanceMonitor::new();\n        \n        monitor.record_query_time(Duration::from_millis(15));\n        monitor.record_query_time(Duration::from_millis(25));\n        monitor.record_index_time(Duration::from_millis(150));\n        \n        let stats = monitor.get_stats();\n        \n        let query_summary = stats.query_performance_summary();\n        assert!(query_summary.contains(\"Query Performance\"));\n        assert!(query_summary.contains(\"avg=\"));\n        assert!(query_summary.contains(\"p95=\"));\n        \n        let index_summary = stats.index_performance_summary();\n        assert!(index_summary.contains(\"Index Performance\"));\n        \n        let full_summary = stats.full_summary();\n        assert!(full_summary.contains(\"Performance Summary\"));\n        assert!(full_summary.contains(\"uptime:\"));\n    }\n}\n```\n\n## Success Criteria\n- [ ] File `src/monitor.rs` created successfully\n- [ ] `PerformanceMonitor` struct compiles without errors\n- [ ] Time recording works for both queries and indexing\n- [ ] Statistical calculations are accurate (average, percentiles)\n- [ ] Sample capacity limiting works correctly\n- [ ] Performance rates are calculated properly\n- [ ] All tests pass\n- [ ] Summary formatting provides useful output\n- [ ] No compilation errors or warnings\n\n## Time Limit\n10 minutes\n\n## Notes\n- Uses VecDeque for efficient FIFO sample management\n- Tracks both recent samples and total lifetime counts\n- Percentile calculations help identify performance outliers\n- Rate calculations provide real-time performance insights\n- Summary methods produce human-readable performance reports