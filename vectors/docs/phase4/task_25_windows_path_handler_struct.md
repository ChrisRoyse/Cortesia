# Task 25: Create WindowsPathHandler Struct

## Context
You are implementing Phase 4 of a vector indexing system. This task begins the Windows optimization component, which handles Windows-specific path normalization, filename validation, and file system optimizations.

## Current State
- Parallel indexing is implemented in `src/parallel.rs`
- Memory efficient caching is implemented in `src/cache.rs` 
- Now implementing Windows-specific optimizations

## Task Objective
Create the `WindowsPathHandler` struct in a new file `src/windows.rs` with methods for Windows path normalization and filename validation.

## Implementation Requirements

### 1. Create `src/windows.rs` file
```rust
use std::path::{Path, PathBuf};\nuse anyhow::Result;\n\npub struct WindowsPathHandler;\n\n// Windows reserved characters that cannot be used in filenames\nconst RESERVED_CHARS: &[char] = &['<', '>', ':', '\"', '|', '?', '*'];\n\n// Windows reserved names (case-insensitive)\nconst RESERVED_NAMES: &[&str] = &[\n    \"CON\", \"PRN\", \"AUX\", \"NUL\",\n    \"COM1\", \"COM2\", \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\",\n    \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", \"LPT9\",\n];\n\n// Maximum path length on Windows (32,767 characters with extended paths)\nconst MAX_WINDOWS_PATH_LENGTH: usize = 32767;\nconst MAX_STANDARD_PATH_LENGTH: usize = 260;\n\nimpl WindowsPathHandler {\n    pub fn new() -> Self {\n        Self\n    }\n    \n    /// Normalize a path for Windows compatibility\n    pub fn normalize_path(path: &Path) -> Result<PathBuf> {\n        // First, try to canonicalize the path\n        let canonical = match path.canonicalize() {\n            Ok(p) => p,\n            Err(_) => {\n                // If canonicalization fails, try to clean the path manually\n                Self::clean_path_components(path)\n            }\n        };\n        \n        #[cfg(windows)]\n        {\n            Self::handle_windows_extended_path(canonical)\n        }\n        \n        #[cfg(not(windows))]\n        {\n            Ok(canonical)\n        }\n    }\n    \n    #[cfg(windows)]\n    fn handle_windows_extended_path(path: PathBuf) -> Result<PathBuf> {\n        let path_str = path.to_string_lossy();\n        \n        // Remove Windows extended path prefix if present\n        if path_str.starts_with(r\"\\\\?\\\") {\n            let cleaned = &path_str[4..];\n            Ok(PathBuf::from(cleaned))\n        } else {\n            Ok(path)\n        }\n    }\n    \n    fn clean_path_components(path: &Path) -> PathBuf {\n        let mut components = Vec::new();\n        \n        for component in path.components() {\n            match component {\n                std::path::Component::CurDir => continue, // Skip \".\"\n                std::path::Component::ParentDir => {\n                    if !components.is_empty() {\n                        components.pop(); // Remove last component for \"..\"\n                    }\n                }\n                _ => components.push(component),\n            }\n        }\n        \n        components.into_iter().collect()\n    }\n    \n    /// Check if a filename is valid on Windows\n    pub fn is_valid_windows_filename(filename: &str) -> bool {\n        if filename.is_empty() {\n            return false;\n        }\n        \n        // Check for reserved characters\n        if filename.chars().any(|c| RESERVED_CHARS.contains(&c)) {\n            return false;\n        }\n        \n        // Check for control characters (0-31)\n        if filename.chars().any(|c| c as u32 <= 31) {\n            return false;\n        }\n        \n        // Check for trailing spaces or periods\n        if filename.ends_with(' ') || filename.ends_with('.') {\n            return false;\n        }\n        \n        // Check for reserved names (case-insensitive)\n        let upper_filename = filename.to_uppercase();\n        let base_name = upper_filename.split('.').next().unwrap_or(\"\");\n        \n        if RESERVED_NAMES.contains(&base_name) {\n            return false;\n        }\n        \n        true\n    }\n    \n    /// Check if a path length is within Windows limits\n    pub fn is_valid_path_length(path: &Path) -> bool {\n        let path_str = path.to_string_lossy();\n        let length = path_str.len();\n        \n        // Check against extended path limit\n        if length > MAX_WINDOWS_PATH_LENGTH {\n            return false;\n        }\n        \n        // Warn if approaching standard limit\n        if length > MAX_STANDARD_PATH_LENGTH {\n            println!(\"Warning: Path length {} exceeds standard Windows limit of {}\", \n                    length, MAX_STANDARD_PATH_LENGTH);\n        }\n        \n        true\n    }\n    \n    /// Validate both filename and path length\n    pub fn validate_windows_path(path: &Path) -> Result<()> {\n        // Check path length\n        if !Self::is_valid_path_length(path) {\n            return Err(anyhow::anyhow!(\"Path too long: {}\", path.display()));\n        }\n        \n        // Check each filename component\n        for component in path.components() {\n            if let std::path::Component::Normal(os_str) = component {\n                let filename = os_str.to_string_lossy();\n                if !Self::is_valid_windows_filename(&filename) {\n                    return Err(anyhow::anyhow!(\"Invalid filename: {}\", filename));\n                }\n            }\n        }\n        \n        Ok(())\n    }\n    \n    /// Get platform-specific path separator\n    pub fn path_separator() -> &'static str {\n        #[cfg(windows)]\n        {\n            \"\\\\\"\n        }\n        #[cfg(not(windows))]\n        {\n            \"/\"\n        }\n    }\n}\n```\n\n### 2. Update `src/lib.rs`\nAdd this line to expose the new module:\n```rust\npub mod windows;\n```\n\n### 3. Add comprehensive tests\nAdd these tests at the bottom of `src/windows.rs`:\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n    use std::fs;\n    \n    #[test]\n    fn test_valid_windows_filenames() {\n        let valid_names = [\n            \"file.txt\",\n            \"document.pdf\",\n            \"my_file.rs\",\n            \"test123.json\",\n            \"file-name.md\",\n            \"file (1).txt\",\n        ];\n        \n        for name in &valid_names {\n            assert!(WindowsPathHandler::is_valid_windows_filename(name),\n                   \"'{}' should be valid\", name);\n        }\n    }\n    \n    #[test]\n    fn test_invalid_windows_filenames() {\n        let invalid_names = [\n            \"file<name>.txt\",  // Contains <\n            \"file>name.txt\",   // Contains >\n            \"file:name.txt\",   // Contains :\n            \"file\\\"name.txt\",   // Contains \"\n            \"file|name.txt\",   // Contains |\n            \"file?name.txt\",   // Contains ?\n            \"file*name.txt\",   // Contains *\n            \"CON\",             // Reserved name\n            \"con.txt\",         // Reserved name with extension\n            \"PRN\",             // Reserved name\n            \"COM1\",            // Reserved name\n            \"LPT1.dat\",        // Reserved name with extension\n            \"file.\",           // Ends with period\n            \"file \",           // Ends with space\n            \"\",                // Empty\n        ];\n        \n        for name in &invalid_names {\n            assert!(!WindowsPathHandler::is_valid_windows_filename(name),\n                   \"'{}' should be invalid\", name);\n        }\n    }\n    \n    #[test]\n    fn test_path_normalization() -> Result<()> {\n        let temp_dir = TempDir::new()?;\n        \n        // Create a test file\n        let test_file = temp_dir.path().join(\"test.txt\");\n        fs::write(&test_file, \"content\")?;\n        \n        // Test normalization with existing file\n        let normalized = WindowsPathHandler::normalize_path(&test_file)?;\n        assert!(normalized.exists());\n        assert!(normalized.is_absolute());\n        \n        Ok(())\n    }\n    \n    #[test]\n    fn test_path_length_validation() {\n        // Test normal path length\n        let normal_path = PathBuf::from(\"C:\\\\Users\\\\test\\\\document.txt\");\n        assert!(WindowsPathHandler::is_valid_path_length(&normal_path));\n        \n        // Test very long path (but within extended limit)\n        let long_path = PathBuf::from(\"C:\\\\\".to_string() + &\"very_long_directory_name\\\\\".repeat(100) + \"file.txt\");\n        // This might be valid or invalid depending on the total length\n        let _ = WindowsPathHandler::is_valid_path_length(&long_path);\n        \n        // Test extremely long path (exceeds all limits)\n        let extremely_long_path = PathBuf::from(\"C:\\\\\".to_string() + &\"x\".repeat(MAX_WINDOWS_PATH_LENGTH + 1));\n        assert!(!WindowsPathHandler::is_valid_path_length(&extremely_long_path));\n    }\n    \n    #[test]\n    fn test_windows_path_validation() -> Result<()> {\n        let temp_dir = TempDir::new()?;\n        \n        // Create valid path\n        let valid_path = temp_dir.path().join(\"valid_file.txt\");\n        assert!(WindowsPathHandler::validate_windows_path(&valid_path).is_ok());\n        \n        // Test invalid filename in path\n        let invalid_path = temp_dir.path().join(\"invalid<file>.txt\");\n        assert!(WindowsPathHandler::validate_windows_path(&invalid_path).is_err());\n        \n        Ok(())\n    }\n    \n    #[test]\n    fn test_path_separator() {\n        let separator = WindowsPathHandler::path_separator();\n        \n        #[cfg(windows)]\n        assert_eq!(separator, \"\\\\\");\n        \n        #[cfg(not(windows))]\n        assert_eq!(separator, \"/\");\n    }\n}\n```\n\n## Success Criteria\n- [ ] File `src/windows.rs` created successfully\n- [ ] `WindowsPathHandler` struct compiles without errors\n- [ ] Path normalization handles Windows extended paths\n- [ ] Filename validation catches all reserved names and characters\n- [ ] Path length validation works correctly\n- [ ] All tests pass on both Windows and non-Windows platforms\n- [ ] No compilation errors or warnings\n\n## Time Limit\n10 minutes\n\n## Notes\n- The code should work on both Windows and non-Windows platforms\n- Windows-specific code is gated behind `#[cfg(windows)]`\n- Path normalization handles both existing and non-existing paths\n- Reserved names are case-insensitive on Windows\n- Path length warnings help identify potential issues