# Task 059: Malicious Query Tests

## Context
You are implementing a comprehensive validation system for a Rust-based vector indexing system. This creates malicious query tests that validates protection against injection attacks, DoS attempts, and adversarial input patterns.

## Project Structure
tests/
  malicious_query_tests.rs  <- Create this file
src/
  validation/
  lib.rs
Cargo.toml

## Task Description
Create comprehensive tests for malicious query protection including injection attempts, denial of service attacks, resource exhaustion, and adversarial patterns.

## Requirements
1. Create comprehensive integration test
2. Test protection against various attack vectors
3. Validate input sanitization and validation
4. Handle resource exhaustion gracefully
5. Ensure 10-minute completion scope

## Expected Code Structure
```rust
use anyhow::Result;
use tempfile::TempDir;
use std::time::{Duration, Instant};

#[tokio::test]
async fn test_injection_attack_protection() -> Result<()> {
    let temp_dir = TempDir::new()?;
    let malicious_tester = MaliciousQueryTester::new(temp_dir.path()).await?;
    
    let injection_attempts = vec![
        // SQL injection patterns
        (\"'; DROP TABLE users; --\", \"SQL drop table injection\"),\n        (\"' OR '1'='1\", \"SQL boolean injection\"),\n        (\"' UNION SELECT * FROM sensitive_data --\", \"SQL union injection\"),\n        (\"'; DELETE FROM * WHERE 1=1; --\", \"SQL delete injection\"),\n        (\"admin'--\", \"SQL comment injection\"),\n        (\"' OR 1=1 LIMIT 1 --\", \"SQL limit injection\"),\n        \n        // NoSQL injection patterns\n        (\"{\\\"$ne\\\": null}\", \"NoSQL not equal injection\"),\n        (\"{\\\"$gt\\\": \\\"\\\"}\", \"NoSQL greater than injection\"),\n        (\"{\\\"$where\\\": \\\"this.username == this.password\\\"}\", \"NoSQL where injection\"),\n        \n        // Command injection patterns\n        (\"; rm -rf /\", \"Command injection rm\"),\n        (\"&& cat /etc/passwd\", \"Command injection cat\"),\n        (\"`whoami`\", \"Command injection backticks\"),\n        (\"$(id)\", \"Command injection subshell\"),\n        (\"| nc -l 4444\", \"Command injection netcat\"),\n        \n        // LDAP injection patterns\n        (\"*)(uid=*))(|(uid=*\", \"LDAP wildcard injection\"),\n        (\"*)(|(password=*))\", \"LDAP password bypass\"),\n        \n        // XPath injection patterns\n        (\"' or '1'='1\", \"XPath boolean injection\"),\n        (\"') or ('1'='1\", \"XPath parentheses injection\"),\n        \n        // Template injection patterns\n        (\"{{7*7}}\", \"Template math injection\"),\n        (\"${7*7}\", \"Template expression injection\"),\n        (\"#{7*7}\", \"Template hash injection\"),\n    ];\n    \n    for (malicious_query, description) in injection_attempts {\n        let start_time = Instant::now();\n        \n        let result = tokio::time::timeout(\n            Duration::from_secs(10),\n            malicious_tester.search(malicious_query)\n        ).await;\n        \n        let elapsed = start_time.elapsed();\n        \n        match result {\n            Ok(Ok(search_results)) => {\n                // If query succeeds, verify it's safely handled\n                assert!(search_results.len() < 1000, \n                       \"Suspicious large result set from injection: {} results for {}\", \n                       search_results.len(), description);\n                \n                // Verify no sensitive data leaked\n                for result in &search_results {\n                    assert!(!result.content.contains(\"password\"),\n                           \"Sensitive data leak in {}: found password\", description);\n                    assert!(!result.content.contains(\"/etc/passwd\"),\n                           \"System file access in {}: found /etc/passwd\", description);\n                    assert!(!result.content.contains(\"DROP TABLE\"),\n                           \"SQL injection executed in {}: found DROP TABLE\", description);\n                }\n                \n                println!(\"Injection attempt safely handled: {} -> {} results\", description, search_results.len());\n            },\n            Ok(Err(e)) => {\n                // Errors are acceptable for malicious input\n                println!(\"Injection attempt rejected: {} -> {}\", description, e);\n            },\n            Err(_) => {\n                // Timeout indicates potential DoS, but system should recover\n                println!(\"Injection attempt timed out: {} (potential DoS detected)\", description);\n            }\n        }\n        \n        // Verify system remains responsive after injection attempt\n        assert!(elapsed < Duration::from_secs(15), \n               \"System unresponsive after injection {}: {:?}\", description, elapsed);\n    }\n    \n    // Verify system is still functional after all injection attempts\n    let recovery_result = malicious_tester.search(\"normal_query\").await?;\n    assert!(!recovery_result.is_empty() || recovery_result.is_empty(), \n           \"System should be functional after injection attempts\");\n    \n    println!(\"Injection attack protection test completed successfully\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_dos_attack_protection() -> Result<()> {\n    let temp_dir = TempDir::new()?;\n    let malicious_tester = MaliciousQueryTester::new(temp_dir.path()).await?;\n    \n    let dos_attack_patterns = vec![\n        // Query length attacks\n        (\"a\".repeat(1_000_000), \"1MB query string\"),\n        (\"search \".repeat(100_000), \"repeated terms attack\"),\n        (\"((((((((((\".repeat(10_000) + \"))))))))))\".repeat(10_000), \"nested parentheses bomb\"),\n        \n        // Regex DoS attacks (catastrophic backtracking)\n        (\"regex:/(a+)+b/\", \"catastrophic backtracking 1\"),\n        (\"regex:/(a*)*b/\", \"catastrophic backtracking 2\"),\n        (\"regex:/(a|a)*b/\", \"catastrophic backtracking 3\"),\n        (\"regex:/^(([a-z])+.)+[A-Z]([a-z])+$/\", \"complex catastrophic regex\"),\n        \n        // Boolean logic bombs\n        (\"a OR \".repeat(10_000) + \"b\", \"OR bomb\"),\n        (\"a AND \".repeat(10_000) + \"b\", \"AND bomb\"),\n        (\"NOT \".repeat(10_000) + \"a\", \"NOT bomb\"),\n        \n        // Wildcard expansion attacks\n        (\"*\".repeat(1000), \"wildcard bomb\"),\n        (\"a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*\", \"alphabet wildcard expansion\"),\n        \n        // Memory exhaustion patterns\n        (\"vector:\" + &\"large semantic query with many terms \".repeat(10_000), \"vector memory bomb\"),\n        (\"phrase:\\\"\" + &\"very long phrase with many words \".repeat(5_000) + \"\\\"\", \"phrase memory bomb\"),\n    ];\n    \n    for (dos_query, description) in dos_attack_patterns {\n        let start_time = Instant::now();\n        let initial_memory = get_memory_usage().unwrap_or(0);\n        \n        let result = tokio::time::timeout(\n            Duration::from_secs(30), // Generous timeout for DoS detection\n            malicious_tester.search(&dos_query)\n        ).await;\n        \n        let elapsed = start_time.elapsed();\n        let current_memory = get_memory_usage().unwrap_or(0);\n        let memory_increase = current_memory.saturating_sub(initial_memory);\n        \n        match result {\n            Ok(Ok(_)) => {\n                // If DoS query succeeds, it should do so quickly and efficiently\n                assert!(elapsed < Duration::from_secs(10),\n                       \"DoS query {} took too long: {:?}\", description, elapsed);\n                assert!(memory_increase < 100_000_000, // 100MB limit\n                       \"DoS query {} used too much memory: {}MB\", description, memory_increase / 1_000_000);\n                println!(\"DoS attack handled efficiently: {} in {:?}\", description, elapsed);\n            },\n            Ok(Err(e)) => {\n                // Rejecting DoS queries is acceptable\n                println!(\"DoS attack rejected: {} -> {}\", description, e);\n            },\n            Err(_) => {\n                // Timeout protection activated\n                println!(\"DoS attack timed out: {} (protection activated)\", description);\n            }\n        }\n        \n        // Verify memory didn't spike excessively\n        assert!(memory_increase < 500_000_000, // 500MB absolute limit\n               \"Excessive memory usage from DoS attack {}: {}MB\", description, memory_increase / 1_000_000);\n    }\n    \n    // Verify system recovery after DoS attempts\n    let recovery_start = Instant::now();\n    let recovery_result = malicious_tester.search(\"recovery_test\").await?;\n    let recovery_time = recovery_start.elapsed();\n    \n    assert!(recovery_time < Duration::from_secs(5),\n           \"System took too long to recover after DoS attacks: {:?}\", recovery_time);\n    \n    println!(\"DoS attack protection test completed successfully\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_adversarial_input_patterns() -> Result<()> {\n    let temp_dir = TempDir::new()?;\n    let malicious_tester = MaliciousQueryTester::new(temp_dir.path()).await?;\n    \n    let adversarial_patterns = vec![\n        // Unicode attacks\n        (\"\\u{202E}override\\u{202C}\", \"right-to-left override attack\"),\n        (\"\\u{FEFF}\".repeat(1000), \"BOM character flood\"),\n        (\"\\u{200B}\".repeat(10000), \"zero-width space attack\"),\n        (\"\\u{0000}\".repeat(1000), \"null character attack\"),\n        \n        // Encoding attacks\n        (\"%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd\", \"URL encoded path traversal\"),\n        (\"\\\\..\\\\..\\\\..\\\\windows\\\\system32\", \"Windows path traversal\"),\n        (\"..%252f..%252f..%252fetc%252fpasswd\", \"double URL encoded traversal\"),\n        \n        // Format string attacks\n        (\"%s%s%s%s%s%s%s%s%s%s\", \"format string attack\"),\n        (\"%x%x%x%x%x%x%x%x%x%x\", \"hex format string attack\"),\n        (\"%n%n%n%n%n%n%n%n%n%n\", \"write format string attack\"),\n        \n        // Buffer overflow patterns\n        (\"A\".repeat(100_000), \"buffer overflow attempt\"),\n        (\"\\0\".repeat(10_000), \"null buffer overflow\"),\n        \n        // XML/HTML attacks\n        (\"<!DOCTYPE html><html><body><script>alert('xss')</script></body></html>\", \"HTML injection\"),\n        (\"<?xml version=\\\"1.0\\\"?><!DOCTYPE test [<!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">]>\", \"XXE injection\"),\n        (\"<svg onload=alert('xss')>\", \"SVG XSS attack\"),\n        \n        // Polyglot attacks (multiple languages)\n        (\"/**/OR/**/1=1#\", \"SQL comment polyglot\"),\n        (\"';alert('xss');//\", \"JavaScript/SQL polyglot\"),\n        (\"{{7*7}}${7*7}#{7*7}\", \"template injection polyglot\"),\n        \n        // Serialization attacks\n        (\"O:8:\\\"stdClass\\\":0:{}\", \"PHP object injection\"),\n        (\"rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcA==\", \"Java serialization attack\"),\n        \n        // Logic bombs\n        (\"search WAIT FOR DELAY '00:00:10'\", \"time delay attack\"),\n        (\"search; BENCHMARK(10000000, MD5('test'))\", \"CPU exhaustion attack\"),\n    ];\n    \n    for (adversarial_query, description) in adversarial_patterns {\n        let start_time = Instant::now();\n        \n        let result = tokio::time::timeout(\n            Duration::from_secs(15),\n            malicious_tester.search(adversarial_query)\n        ).await;\n        \n        let elapsed = start_time.elapsed();\n        \n        match result {\n            Ok(Ok(search_results)) => {\n                // Verify adversarial input is safely handled\n                for result in &search_results {\n                    assert!(!result.content.contains(\"<script\"),\n                           \"XSS vulnerability in {}: script tag found\", description);\n                    assert!(!result.content.contains(\"/etc/passwd\"),\n                           \"Path traversal in {}: system file access\", description);\n                    assert!(!result.content.contains(\"alert(\"),\n                           \"Code execution in {}: alert function found\", description);\n                }\n                println!(\"Adversarial input safely handled: {} -> {} results\", description, search_results.len());\n            },\n            Ok(Err(e)) => {\n                println!(\"Adversarial input rejected: {} -> {}\", description, e);\n            },\n            Err(_) => {\n                println!(\"Adversarial input timed out: {} (protection activated)\", description);\n            }\n        }\n        \n        // Verify reasonable response time\n        assert!(elapsed < Duration::from_secs(20),\n               \"Adversarial input {} caused excessive delay: {:?}\", description, elapsed);\n    }\n    \n    println!(\"Adversarial input patterns test completed successfully\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_resource_exhaustion_protection() -> Result<()> {\n    let temp_dir = TempDir::new()?;\n    let malicious_tester = MaliciousQueryTester::new(temp_dir.path()).await?;\n    \n    // Test concurrent resource exhaustion attempts\n    let concurrent_attacks = 50;\n    let mut handles = Vec::new();\n    \n    let attack_patterns = vec![\n        \"a\".repeat(50_000),\n        \"regex:/(a+)+b/\",\n        \"vector:\" + &\"memory exhaustion test \".repeat(1000),\n        \"*\".repeat(500),\n        \"(\" + &\"nested \".repeat(1000) + &\")\".repeat(1000),\n    ];\n    \n    for attack_id in 0..concurrent_attacks {\n        let malicious_tester_clone = malicious_tester.clone();\n        let pattern = attack_patterns[attack_id % attack_patterns.len()].clone();\n        \n        let handle = tokio::spawn(async move {\n            let start_time = Instant::now();\n            \n            let result = tokio::time::timeout(\n                Duration::from_secs(20),\n                malicious_tester_clone.search(&pattern)\n            ).await;\n            \n            let elapsed = start_time.elapsed();\n            \n            match result {\n                Ok(Ok(_)) => (\"success\", elapsed),\n                Ok(Err(_)) => (\"error\", elapsed),\n                Err(_) => (\"timeout\", elapsed),\n            }\n        });\n        handles.push(handle);\n    }\n    \n    // Wait for all concurrent attacks to complete\n    let mut success_count = 0;\n    let mut error_count = 0;\n    let mut timeout_count = 0;\n    let mut total_time = Duration::ZERO;\n    \n    for handle in handles {\n        let (status, elapsed) = handle.await?;\n        total_time += elapsed;\n        \n        match status {\n            \"success\" => success_count += 1,\n            \"error\" => error_count += 1,\n            \"timeout\" => timeout_count += 1,\n            _ => {}\n        }\n    }\n    \n    let avg_response_time = total_time / concurrent_attacks;\n    \n    // Assertions for resource exhaustion protection\n    assert!(timeout_count < concurrent_attacks / 2,\n           \"Too many timeouts: {} out of {}\", timeout_count, concurrent_attacks);\n    \n    assert!(avg_response_time < Duration::from_secs(10),\n           \"Average response time too high under attack: {:?}\", avg_response_time);\n    \n    // Verify system is still responsive after attacks\n    let recovery_result = malicious_tester.search(\"normal_recovery_query\").await?;\n    \n    println!(\"Resource exhaustion protection: {}/{} attacks handled, avg time {:?}\", \n             success_count + error_count, concurrent_attacks, avg_response_time);\n    \n    Ok(())\n}\n\nfn get_memory_usage() -> Result<u64> {\n    #[cfg(unix)]\n    {\n        use std::fs;\n        let contents = fs::read_to_string(\"/proc/self/status\")?;\n        for line in contents.lines() {\n            if line.starts_with(\"VmRSS:\") {\n                let parts: Vec<&str> = line.split_whitespace().collect();\n                if parts.len() >= 2 {\n                    return Ok(parts[1].parse::<u64>()? * 1024);\n                }\n            }\n        }\n        Ok(0)\n    }\n    \n    #[cfg(windows)]\n    {\n        // Simplified for Windows\n        Ok(0)\n    }\n    \n    #[cfg(not(any(unix, windows)))]\n    {\n        Ok(0)\n    }\n}\n```\n\n## Success Criteria\n- All injection attempts are safely handled or rejected\n- DoS attacks are mitigated with timeouts and resource limits\n- Adversarial input patterns don't cause system compromise\n- Resource exhaustion attacks are contained\n- System remains responsive during and after attacks\n- No sensitive data is leaked through malicious queries\n- Memory usage stays within reasonable bounds during attacks\n- Concurrent malicious queries don't bring down the system\n- Recovery time after attacks is < 5 seconds\n- Protection mechanisms activate without false positives\n\n## Time Limit\n10 minutes maximum